<?php
namespace com\boxalino\dataintelligence\api\thrift;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * This enumeration defines the possible exception states returned by Boxalino Data Intelligence Thrift API
 */
final class DataIntelligenceServiceExceptionNumber {
  /**
   * general case of exception (no special detailed provided)
   */
  const GENERAL_EXCEPTION = 1;
  /**
   * the provided credentials to retrieve an authentication token are not valid (wrong username, password or both)
   */
  const INVALID_CREDENTIALS = 2;
  /**
   * your user has been blocked (but it doesn't necessarily mean your account has been blocked)
   */
  const BLOCKED_USER = 3;
  /**
   * your account has been blocked, you must contact Boxalino (<a href="mailto:support@boxalino.com">support@boxalino.com</a>) to know the reasons of this blocking.
   */
  const BLOCKED_ACCOUNT = 4;
  /**
   * the provided authentication token is invalid (wrong, or no more valid), you should get a new one by calling the GetAuthentication service.
   */
  const INVALID_AUTHENTICATION_TOKEN = 5;
  /**
   * specific to the service function UpdatePassword: means that the new password is not correct (should be at least 8 characters long and not contain any punctuation)
   */
  const INVALID_NEW_PASSWORD = 6;
  /**
   * the provided configuration object contains a configuration version number which doesn't exists or cannot be accessed
   */
  const INVALID_CONFIGURATION_VERSION = 7;
  /**
   * the provided XML data source is not correct (see documentation of the data source XML format)
   */
  const INVALID_DATASOURCE = 8;
  /**
   * the provided content to be changed (updated, deleted, etc.) is defined with a content id which doesn't exists
   */
  const NON_EXISTING_CONTENT_ID = 9;
  /**
   * the provided content id to be created already exists
   */
  const ALREADY_EXISTING_CONTENT_ID = 10;
  /**
   * the provided content id doesn't not match the requested format (less than 50 alphanumeric characters without any punctuation or accent)
   */
  const INVALID_CONTENT_ID = 11;
  /**
   * the provided content data are not correctly set
   */
  const INVALID_CONTENT = 12;
  /**
   * one of the provided languages has not been defined for this account
   */
  const INVALID_LANGUAGE = 13;
  const DUPLICATED_FILE_ID = 14;
  const EMPTY_COLUMNS_LIST = 15;
  const NON_EXISTING_FILE = 16;
  const INVALID_RANGE = 17;
  static public $__names = array(
    1 => 'GENERAL_EXCEPTION',
    2 => 'INVALID_CREDENTIALS',
    3 => 'BLOCKED_USER',
    4 => 'BLOCKED_ACCOUNT',
    5 => 'INVALID_AUTHENTICATION_TOKEN',
    6 => 'INVALID_NEW_PASSWORD',
    7 => 'INVALID_CONFIGURATION_VERSION',
    8 => 'INVALID_DATASOURCE',
    9 => 'NON_EXISTING_CONTENT_ID',
    10 => 'ALREADY_EXISTING_CONTENT_ID',
    11 => 'INVALID_CONTENT_ID',
    12 => 'INVALID_CONTENT',
    13 => 'INVALID_LANGUAGE',
    14 => 'DUPLICATED_FILE_ID',
    15 => 'EMPTY_COLUMNS_LIST',
    16 => 'NON_EXISTING_FILE',
    17 => 'INVALID_RANGE',
  );
}

/**
 * This enumeration defines the version type. All contents are versioned, normally, you want to change the current development version and then, when finished, publish it (so it becomes the new production version and a new development version is created), but it is also possible to access the production version directly
 */
final class ConfigurationVersionType {
  /**
   * this is the normal case, as you want to retrieve the current dev version of your account configuration and not touch the production one
   */
  const CURRENT_DEVELOPMENT_VERSION = 1;
  /**
   * this should only be used in rare cases where you want to recuperate information from the production configuration, but be careful in changing this version as it will immediately affect your production processes!
   */
  const CURRENT_PRODUCTION_VERSION = 2;
  static public $__names = array(
    1 => 'CURRENT_DEVELOPMENT_VERSION',
    2 => 'CURRENT_PRODUCTION_VERSION',
  );
}

final class Language {
  const GERMAN = 1;
  const FRENCH = 2;
  const ENGLISH = 3;
  const ITALIAN = 4;
  const SPANISH = 5;
  const DUTCH = 6;
  const PORTUGUESE = 7;
  const SWEDISH = 8;
  const ARABIC = 9;
  const RUSSIAN = 10;
  const JAPANESE = 11;
  const KOREAN = 12;
  const TURKISH = 13;
  const VIETNAMESE = 14;
  const POLISH = 15;
  const UKRAINIAN = 16;
  const CHINESE_MANDARIN = 17;
  const OTHER = 100;
  static public $__names = array(
    1 => 'GERMAN',
    2 => 'FRENCH',
    3 => 'ENGLISH',
    4 => 'ITALIAN',
    5 => 'SPANISH',
    6 => 'DUTCH',
    7 => 'PORTUGUESE',
    8 => 'SWEDISH',
    9 => 'ARABIC',
    10 => 'RUSSIAN',
    11 => 'JAPANESE',
    12 => 'KOREAN',
    13 => 'TURKISH',
    14 => 'VIETNAMESE',
    15 => 'POLISH',
    16 => 'UKRAINIAN',
    17 => 'CHINESE_MANDARIN',
    100 => 'OTHER',
  );
}

/**
 * This enumeration defines the possible process task execution statuses type (to check the completion of an execution of  process task and its result)
 */
final class ProcessTaskExecutionStatusType {
  /**
   * The process was not started yet
   */
  const WAITING = 1;
  /**
   * The process has started and is currently running
   */
  const STARTED = 2;
  /**
   * The process has finished successfully
   */
  const FINISHED_SUCCESS = 3;
  /**
   * The process has finished, but with some warnings
   */
  const FINISHED_WITH_WARNINGS = 4;
  /**
   * The process has failed
   */
  const FAILED = 5;
  /**
   * The process has been aborted
   */
  const ABORTED = 6;
  static public $__names = array(
    1 => 'WAITING',
    2 => 'STARTED',
    3 => 'FINISHED_SUCCESS',
    4 => 'FINISHED_WITH_WARNINGS',
    5 => 'FAILED',
    6 => 'ABORTED',
  );
}

/**
 * This enumeration defines possible types of columns which can be used in a reference CSV file
 */
final class CSVFileColumnType {
  /**
   * text string encoded using UTF-8 encoding
   */
  const STRING = 1;
  /**
   * signed 64-bit integer
   */
  const INTEGER = 2;
  /**
   * floating point number
   */
  const DOUBLE = 3;
  /**
   * textual representation of the date and time in the format YYYY-MM-DD HH:MM:SS
   */
  const DATETIME = 4;
  /**
   * textual representation of the date in the format YYYY-MM-DD
   */
  const DATE = 5;
  /**
   * textual representation of the time in the format HH:MM:SS
   */
  const TIME = 6;
  /**
   * numerical representation of the date and time as an unsigned 32-bit integer, counting the seconds since the start of the UNIX epoch
   */
  const UNIX_TIMESTAMP = 7;
  static public $__names = array(
    1 => 'STRING',
    2 => 'INTEGER',
    3 => 'DOUBLE',
    4 => 'DATETIME',
    5 => 'DATE',
    6 => 'TIME',
    7 => 'UNIX_TIMESTAMP',
  );
}

/**
 * This enumeration defines possible granularities used in time ranges
 */
final class TimeRangePrecision {
  /**
   * daily precision
   */
  const DAY = 1;
  /**
   * weekly precision
   */
  const WEEK = 2;
  /**
   * monthly precision
   */
  const MONTH = 3;
  static public $__names = array(
    1 => 'DAY',
    2 => 'WEEK',
    3 => 'MONTH',
  );
}

/**
 * This exception is raised by all the BoxalinoDataIntelligence service function in case of a problem
 */
class DataIntelligenceServiceException extends TException {
  static $_TSPEC;

  /**
   * indicate the exception number based on the enumeration DataIntelligenceServiceExceptionNumber
   * 
   * @var int
   */
  public $exceptionNumber = null;
  /**
   * a textual message to explain the error conditions more in details
   * 
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'exceptionNumber',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['exceptionNumber'])) {
        $this->exceptionNumber = $vals['exceptionNumber'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'DataIntelligenceServiceException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->exceptionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataIntelligenceServiceException');
    if ($this->exceptionNumber !== null) {
      $xfer += $output->writeFieldBegin('exceptionNumber', TType::I32, 1);
      $xfer += $output->writeI32($this->exceptionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the parameters to be send to receive an authentication token (required by all the other services)
 */
class AuthenticationRequest {
  static $_TSPEC;

  /**
   * the name of your account (as provided to you by Boxalino team, if you don't have an account, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $account = null;
  /**
   * usually the same value as account (but can be different for users with smaller rights, if you don't have a username, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $username = null;
  /**
   * as provided by Boxalino, or according to the last password update you have set. If you lost your password, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $password = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'account',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['account'])) {
        $this->account = $vals['account'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->account);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthenticationRequest');
    if ($this->account !== null) {
      $xfer += $output->writeFieldBegin('account', TType::STRING, 1);
      $xfer += $output->writeString($this->account);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the authentication object (to pass as authentication proof to all function and services)
 */
class Authentication {
  static $_TSPEC;

  /**
   * the return authentication token is a string valid for one hour
   * 
   * @var string
   */
  public $authenticationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authenticationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['authenticationToken'])) {
        $this->authenticationToken = $vals['authenticationToken'];
      }
    }
  }

  public function getName() {
    return 'Authentication';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->authenticationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Authentication');
    if ($this->authenticationToken !== null) {
      $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
      $xfer += $output->writeString($this->authenticationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration version of your account. It must be provided to all functions accessing / updating or removing information from your account configuration
 */
class ConfigurationVersion {
  static $_TSPEC;

  /**
   * an internal number identifying the configuration version
   * 
   * @var int
   */
  public $configurationVersionNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'configurationVersionNumber',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['configurationVersionNumber'])) {
        $this->configurationVersionNumber = $vals['configurationVersionNumber'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationVersion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->configurationVersionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationVersion');
    if ($this->configurationVersionNumber !== null) {
      $xfer += $output->writeFieldBegin('configurationVersionNumber', TType::I16, 1);
      $xfer += $output->writeI16($this->configurationVersionNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration difference (somethin which has changed between two configuration versions)
 */
class ConfigurationDifference {
  static $_TSPEC;

  /**
   * the type of content which has changed (e.g.: 'field')
   * 
   * @var string
   */
  public $contentType = null;
  /**
   * the content id which has changed (e.g: a field id)
   * 
   * @var string
   */
  public $contentId = null;
  /**
   * the content parameter which has changed (e.g.: a field type)
   * 
   * @var string
   */
  public $parameterName = null;
  /**
   * the string encoded value of the content parameter value of the source configuration
   * 
   * @var string
   */
  public $contentSource = null;
  /**
   * the string encoded value of the content parameter value of the destination configuration
   * 
   * @var string
   */
  public $contentDestination = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contentType',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'contentId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameterName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'contentSource',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'contentDestination',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contentType'])) {
        $this->contentType = $vals['contentType'];
      }
      if (isset($vals['contentId'])) {
        $this->contentId = $vals['contentId'];
      }
      if (isset($vals['parameterName'])) {
        $this->parameterName = $vals['parameterName'];
      }
      if (isset($vals['contentSource'])) {
        $this->contentSource = $vals['contentSource'];
      }
      if (isset($vals['contentDestination'])) {
        $this->contentDestination = $vals['contentDestination'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationDifference';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parameterName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentSource);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentDestination);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationDifference');
    if ($this->contentType !== null) {
      $xfer += $output->writeFieldBegin('contentType', TType::STRING, 1);
      $xfer += $output->writeString($this->contentType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentId !== null) {
      $xfer += $output->writeFieldBegin('contentId', TType::STRING, 2);
      $xfer += $output->writeString($this->contentId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameterName !== null) {
      $xfer += $output->writeFieldBegin('parameterName', TType::STRING, 3);
      $xfer += $output->writeString($this->parameterName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentSource !== null) {
      $xfer += $output->writeFieldBegin('contentSource', TType::STRING, 4);
      $xfer += $output->writeString($this->contentSource);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentDestination !== null) {
      $xfer += $output->writeFieldBegin('contentDestination', TType::STRING, 5);
      $xfer += $output->writeString($this->contentDestination);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Field. A field covers any type of data property (customer property, product properties, etc.). Fields are global for all data sources, but can be used only for special data sources and ignored for others. This grants that the properties are always ready to unify values from different sources, but they don't have to.
 */
class Field {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $fieldId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldId'])) {
        $this->fieldId = $vals['fieldId'];
      }
    }
  }

  public function getName() {
    return 'Field';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Field');
    if ($this->fieldId !== null) {
      $xfer += $output->writeFieldBegin('fieldId', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data ProcessTask. A process task covers any kind of process task to be executed by the system.
 */
class ProcessTask {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $processTaskId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
    }
  }

  public function getName() {
    return 'ProcessTask';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTask');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data synchronisation process task. It is used to get the data from external systems and process it.
 */
class DataSyncProcessTask {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $processTaskId = null;
  /**
   * list of data sources which should be used to get data from
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\DataSource[]
   */
  public $inputs = null;
  /**
   * list of data exports which should be used to push the data into
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\DataExport[]
   */
  public $outputs = null;
  /**
   * defines if it is dev version of the task process
   * 
   * @var bool
   */
  public $dev = false;
  /**
   * defines if this particular task process is differential
   * 
   * @var bool
   */
  public $delta = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'inputs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\DataSource',
            ),
          ),
        3 => array(
          'var' => 'outputs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\DataExport',
            ),
          ),
        4 => array(
          'var' => 'dev',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
      if (isset($vals['inputs'])) {
        $this->inputs = $vals['inputs'];
      }
      if (isset($vals['outputs'])) {
        $this->outputs = $vals['outputs'];
      }
      if (isset($vals['dev'])) {
        $this->dev = $vals['dev'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
    }
  }

  public function getName() {
    return 'DataSyncProcessTask';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->inputs = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \com\boxalino\dataintelligence\api\thrift\DataSource();
              $xfer += $elem5->read($input);
              $this->inputs []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->outputs = array();
            $_size6 = 0;
            $_etype9 = 0;
            $xfer += $input->readListBegin($_etype9, $_size6);
            for ($_i10 = 0; $_i10 < $_size6; ++$_i10)
            {
              $elem11 = null;
              $elem11 = new \com\boxalino\dataintelligence\api\thrift\DataExport();
              $xfer += $elem11->read($input);
              $this->outputs []= $elem11;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->dev);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataSyncProcessTask');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inputs !== null) {
      if (!is_array($this->inputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('inputs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->inputs));
        {
          foreach ($this->inputs as $iter12)
          {
            $xfer += $iter12->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->outputs !== null) {
      if (!is_array($this->outputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('outputs', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->outputs));
        {
          foreach ($this->outputs as $iter13)
          {
            $xfer += $iter13->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dev !== null) {
      $xfer += $output->writeFieldBegin('dev', TType::BOOL, 4);
      $xfer += $output->writeBool($this->dev);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 5);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task Scheduling. A scheduling is a collection of process tasks to be executed one after the other by the system.
 */
class Scheduling {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $schedulingId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
    }
  }

  public function getName() {
    return 'Scheduling';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Scheduling');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task RecommendationBlock. A RecommendationBlock is a visual block of recommendation for one page of your web-site (product detail page, basket page, etc.) you can have several recommendation blocks on the same page.
 */
class RecommendationBlock {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $recommendationBlockId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'recommendationBlockId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['recommendationBlockId'])) {
        $this->recommendationBlockId = $vals['recommendationBlockId'];
      }
    }
  }

  public function getName() {
    return 'RecommendationBlock';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->recommendationBlockId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RecommendationBlock');
    if ($this->recommendationBlockId !== null) {
      $xfer += $output->writeFieldBegin('recommendationBlockId', TType::STRING, 1);
      $xfer += $output->writeString($this->recommendationBlockId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data source. Data source is used to get the data from external systems into DI.
 */
class DataSource {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataSourceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataSourceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataSourceId'])) {
        $this->dataSourceId = $vals['dataSourceId'];
      }
    }
  }

  public function getName() {
    return 'DataSource';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataSource');
    if ($this->dataSourceId !== null) {
      $xfer += $output->writeFieldBegin('dataSourceId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data source type used to get the data from reference csv files defined with the API
 */
class ReferenceCSVDataSource {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataSourceId = null;
  /**
   * identifier of the data source which will be extended by this data source
   * 
   * @var string
   */
  public $extendedDataSourceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataSourceId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'extendedDataSourceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataSourceId'])) {
        $this->dataSourceId = $vals['dataSourceId'];
      }
      if (isset($vals['extendedDataSourceId'])) {
        $this->extendedDataSourceId = $vals['extendedDataSourceId'];
      }
    }
  }

  public function getName() {
    return 'ReferenceCSVDataSource';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->extendedDataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReferenceCSVDataSource');
    if ($this->dataSourceId !== null) {
      $xfer += $output->writeFieldBegin('dataSourceId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->extendedDataSourceId !== null) {
      $xfer += $output->writeFieldBegin('extendedDataSourceId', TType::STRING, 2);
      $xfer += $output->writeString($this->extendedDataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data export type used to push processed data into
 */
class DataExport {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataExportId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataExportId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataExportId'])) {
        $this->dataExportId = $vals['dataExportId'];
      }
    }
  }

  public function getName() {
    return 'DataExport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataExportId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataExport');
    if ($this->dataExportId !== null) {
      $xfer += $output->writeFieldBegin('dataExportId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataExportId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data EmailCampaign. A campaign is a parameter holder for a campaign execution. It should not change at each sending, but the parameters (especially cmpid) can and should be changed before any new campaign sending (if new campid applies). For the case of trigger campaigns, the cmpid (and other parameters) usually don't change, but for the case of newsletter campaigns, very often each sending has a different id. In this case, the cmpid must be updated (and the dev configuration should be published) every time.
 */
class EmailCampaign {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $emailCampaignId = null;
  /**
   * the running campaign id which is often specific to the running of a specific newsletter e-mail (should be changed every time before sending a blast e-mail with the new value (don't forget to publish the dev configuration)
   * 
   * @var string
   */
  public $cmpid = null;
  /**
   * the dateTime at which the campaign will be sent (cannot be in the past when the campaign is ran, an exception will be then raised). Must have the format YYYY-MM-DD HH:MM:SS
   * 
   * @var string
   */
  public $dateTime = null;
  /**
   * a localized value of the base url to use for e-mail links
   * 
   * @var array
   */
  public $baseUrl = null;
  /**
   * a localized value of the subject line of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'subject')
   * 
   * @var array
   */
  public $subject = null;
  /**
   * a localized value of the first sentence of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'firstSentence')
   * 
   * @var array
   */
  public $firstSentence = null;
  /**
   * a localized value of the legal notices to be included in the e-mail (default, can be extended by a specific choice variant localized parameters with parameter name 'legals')
   * 
   * @var array
   */
  public $legals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'emailCampaignId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'cmpid',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'dateTime',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'baseUrl',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'subject',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'firstSentence',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        7 => array(
          'var' => 'legals',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['emailCampaignId'])) {
        $this->emailCampaignId = $vals['emailCampaignId'];
      }
      if (isset($vals['cmpid'])) {
        $this->cmpid = $vals['cmpid'];
      }
      if (isset($vals['dateTime'])) {
        $this->dateTime = $vals['dateTime'];
      }
      if (isset($vals['baseUrl'])) {
        $this->baseUrl = $vals['baseUrl'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
      if (isset($vals['firstSentence'])) {
        $this->firstSentence = $vals['firstSentence'];
      }
      if (isset($vals['legals'])) {
        $this->legals = $vals['legals'];
      }
    }
  }

  public function getName() {
    return 'EmailCampaign';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->emailCampaignId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cmpid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dateTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->baseUrl = array();
            $_size14 = 0;
            $_ktype15 = 0;
            $_vtype16 = 0;
            $xfer += $input->readMapBegin($_ktype15, $_vtype16, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $key19 = 0;
              $val20 = '';
              $xfer += $input->readI32($key19);
              $xfer += $input->readString($val20);
              $this->baseUrl[$key19] = $val20;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->subject = array();
            $_size21 = 0;
            $_ktype22 = 0;
            $_vtype23 = 0;
            $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $key26 = 0;
              $val27 = '';
              $xfer += $input->readI32($key26);
              $xfer += $input->readString($val27);
              $this->subject[$key26] = $val27;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->firstSentence = array();
            $_size28 = 0;
            $_ktype29 = 0;
            $_vtype30 = 0;
            $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $key33 = 0;
              $val34 = '';
              $xfer += $input->readI32($key33);
              $xfer += $input->readString($val34);
              $this->firstSentence[$key33] = $val34;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->legals = array();
            $_size35 = 0;
            $_ktype36 = 0;
            $_vtype37 = 0;
            $xfer += $input->readMapBegin($_ktype36, $_vtype37, $_size35);
            for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
            {
              $key40 = 0;
              $val41 = '';
              $xfer += $input->readI32($key40);
              $xfer += $input->readString($val41);
              $this->legals[$key40] = $val41;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmailCampaign');
    if ($this->emailCampaignId !== null) {
      $xfer += $output->writeFieldBegin('emailCampaignId', TType::STRING, 1);
      $xfer += $output->writeString($this->emailCampaignId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cmpid !== null) {
      $xfer += $output->writeFieldBegin('cmpid', TType::STRING, 2);
      $xfer += $output->writeString($this->cmpid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateTime !== null) {
      $xfer += $output->writeFieldBegin('dateTime', TType::STRING, 3);
      $xfer += $output->writeString($this->dateTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->baseUrl !== null) {
      if (!is_array($this->baseUrl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('baseUrl', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->baseUrl));
        {
          foreach ($this->baseUrl as $kiter42 => $viter43)
          {
            $xfer += $output->writeI32($kiter42);
            $xfer += $output->writeString($viter43);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      if (!is_array($this->subject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subject', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->subject));
        {
          foreach ($this->subject as $kiter44 => $viter45)
          {
            $xfer += $output->writeI32($kiter44);
            $xfer += $output->writeString($viter45);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->firstSentence !== null) {
      if (!is_array($this->firstSentence)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('firstSentence', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->firstSentence));
        {
          foreach ($this->firstSentence as $kiter46 => $viter47)
          {
            $xfer += $output->writeI32($kiter46);
            $xfer += $output->writeString($viter47);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legals !== null) {
      if (!is_array($this->legals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('legals', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->legals));
        {
          foreach ($this->legals as $kiter48 => $viter49)
          {
            $xfer += $output->writeI32($kiter48);
            $xfer += $output->writeString($viter49);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice.
 */
class Choice {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $choiceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
    }
  }

  public function getName() {
    return 'Choice';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Choice');
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice variant
 */
class ChoiceVariant {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $choiceVariantId = null;
  /**
   * the choice id of the choice which this variant is associated to
   * 
   * @var string
   */
  public $choiceId = null;
  /**
   * a list of tags this variant is connected to
   * 
   * @var string[]
   */
  public $tags = null;
  /**
   * a list of non-localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
   * 
   * @var array
   */
  public $simpleParameters = null;
  /**
   * a list of localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
   * 
   * @var array
   */
  public $localizedParemeters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceVariantId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'simpleParameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        5 => array(
          'var' => 'localizedParemeters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::MAP,
            'elem' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::STRING,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::STRING,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceVariantId'])) {
        $this->choiceVariantId = $vals['choiceVariantId'];
      }
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['simpleParameters'])) {
        $this->simpleParameters = $vals['simpleParameters'];
      }
      if (isset($vals['localizedParemeters'])) {
        $this->localizedParemeters = $vals['localizedParemeters'];
      }
    }
  }

  public function getName() {
    return 'ChoiceVariant';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceVariantId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size50 = 0;
            $_etype53 = 0;
            $xfer += $input->readListBegin($_etype53, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $elem55 = null;
              $xfer += $input->readString($elem55);
              $this->tags []= $elem55;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->simpleParameters = array();
            $_size56 = 0;
            $_ktype57 = 0;
            $_vtype58 = 0;
            $xfer += $input->readMapBegin($_ktype57, $_vtype58, $_size56);
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $key61 = '';
              $val62 = array();
              $xfer += $input->readString($key61);
              $val62 = array();
              $_size63 = 0;
              $_etype66 = 0;
              $xfer += $input->readListBegin($_etype66, $_size63);
              for ($_i67 = 0; $_i67 < $_size63; ++$_i67)
              {
                $elem68 = null;
                $xfer += $input->readString($elem68);
                $val62 []= $elem68;
              }
              $xfer += $input->readListEnd();
              $this->simpleParameters[$key61] = $val62;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->localizedParemeters = array();
            $_size69 = 0;
            $_ktype70 = 0;
            $_vtype71 = 0;
            $xfer += $input->readMapBegin($_ktype70, $_vtype71, $_size69);
            for ($_i73 = 0; $_i73 < $_size69; ++$_i73)
            {
              $key74 = '';
              $val75 = array();
              $xfer += $input->readString($key74);
              $val75 = array();
              $_size76 = 0;
              $_etype79 = 0;
              $xfer += $input->readListBegin($_etype79, $_size76);
              for ($_i80 = 0; $_i80 < $_size76; ++$_i80)
              {
                $elem81 = null;
                $elem81 = array();
                $_size82 = 0;
                $_ktype83 = 0;
                $_vtype84 = 0;
                $xfer += $input->readMapBegin($_ktype83, $_vtype84, $_size82);
                for ($_i86 = 0; $_i86 < $_size82; ++$_i86)
                {
                  $key87 = 0;
                  $val88 = '';
                  $xfer += $input->readI32($key87);
                  $xfer += $input->readString($val88);
                  $elem81[$key87] = $val88;
                }
                $xfer += $input->readMapEnd();
                $val75 []= $elem81;
              }
              $xfer += $input->readListEnd();
              $this->localizedParemeters[$key74] = $val75;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceVariant');
    if ($this->choiceVariantId !== null) {
      $xfer += $output->writeFieldBegin('choiceVariantId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceVariantId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 2);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $iter89)
          {
            $xfer += $output->writeString($iter89);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->simpleParameters !== null) {
      if (!is_array($this->simpleParameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('simpleParameters', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->simpleParameters));
        {
          foreach ($this->simpleParameters as $kiter90 => $viter91)
          {
            $xfer += $output->writeString($kiter90);
            {
              $output->writeListBegin(TType::STRING, count($viter91));
              {
                foreach ($viter91 as $iter92)
                {
                  $xfer += $output->writeString($iter92);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localizedParemeters !== null) {
      if (!is_array($this->localizedParemeters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('localizedParemeters', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->localizedParemeters));
        {
          foreach ($this->localizedParemeters as $kiter93 => $viter94)
          {
            $xfer += $output->writeString($kiter93);
            {
              $output->writeListBegin(TType::MAP, count($viter94));
              {
                foreach ($viter94 as $iter95)
                {
                  {
                    $output->writeMapBegin(TType::I32, TType::STRING, count($iter95));
                    {
                      foreach ($iter95 as $kiter96 => $viter97)
                      {
                        $xfer += $output->writeI32($kiter96);
                        $xfer += $output->writeString($viter97);
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a process task execution status (the status of execution of a process task) with its type and a textual message
 */
class ProcessTaskExecutionStatus {
  static $_TSPEC;

  /**
   * the status type of this execution of the process task
   * 
   * @var int
   */
  public $statusType = null;
  /**
   * some additonal information about the type (can be empty, used to explain errors and warnings)
   * 
   * @var string
   */
  public $information = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statusType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'information',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statusType'])) {
        $this->statusType = $vals['statusType'];
      }
      if (isset($vals['information'])) {
        $this->information = $vals['information'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionStatus';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->statusType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->information);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionStatus');
    if ($this->statusType !== null) {
      $xfer += $output->writeFieldBegin('statusType', TType::I32, 1);
      $xfer += $output->writeI32($this->statusType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->information !== null) {
      $xfer += $output->writeFieldBegin('information', TType::STRING, 2);
      $xfer += $output->writeString($this->information);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the execution parameters of a process task
 */
class ProcessTaskExecutionParameters {
  static $_TSPEC;

  /**
   * the process task id to execute
   * 
   * @var string
   */
  public $processTaskId = null;
  /**
   * should the process run with development data that should not to be published into the production environment
   * 
   * @var bool
   */
  public $development = null;
  /**
   * is the process a differential process that adds or updates a part of the existing data, otherwise the new data will replace any existing data completely
   * 
   * @var bool
   */
  public $delta = null;
  /**
   * if another similar process is already running, the forceStart flag will make the new one run, otherwise, the execution will be aborted
   * 
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionParameters');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a reference CSV file descriptor with the identifier and schema
 */
class ReferenceCSVFileDescriptor {
  static $_TSPEC;

  /**
   * identifier of the csv file, needs to be unique per account
   * 
   * @var string
   */
  public $fileId = null;
  /**
   * key-value map of the file columns, where key is a name of the column and value is a column's type
   * 
   * @var array
   */
  public $fileColumns = null;
  /**
   * internal hash used for csv file upload - this property is set by the API and cannot be changed
   * 
   * @var string
   */
  public $fileHash = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'fileColumns',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        3 => array(
          'var' => 'fileHash',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileId'])) {
        $this->fileId = $vals['fileId'];
      }
      if (isset($vals['fileColumns'])) {
        $this->fileColumns = $vals['fileColumns'];
      }
      if (isset($vals['fileHash'])) {
        $this->fileHash = $vals['fileHash'];
      }
    }
  }

  public function getName() {
    return 'ReferenceCSVFileDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->fileColumns = array();
            $_size98 = 0;
            $_ktype99 = 0;
            $_vtype100 = 0;
            $xfer += $input->readMapBegin($_ktype99, $_vtype100, $_size98);
            for ($_i102 = 0; $_i102 < $_size98; ++$_i102)
            {
              $key103 = '';
              $val104 = 0;
              $xfer += $input->readString($key103);
              $xfer += $input->readI32($val104);
              $this->fileColumns[$key103] = $val104;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fileHash);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReferenceCSVFileDescriptor');
    if ($this->fileId !== null) {
      $xfer += $output->writeFieldBegin('fileId', TType::STRING, 1);
      $xfer += $output->writeString($this->fileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileColumns !== null) {
      if (!is_array($this->fileColumns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileColumns', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->fileColumns));
        {
          foreach ($this->fileColumns as $kiter105 => $viter106)
          {
            $xfer += $output->writeString($kiter105);
            $xfer += $output->writeI32($viter106);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileHash !== null) {
      $xfer += $output->writeFieldBegin('fileHash', TType::STRING, 3);
      $xfer += $output->writeString($this->fileHash);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a schedulings execution parameters. A scheduling is a collection of process tasks to be executed one after the other by the system.
 */
class SchedulingExecutionParameters {
  static $_TSPEC;

  /**
   * the scheduling id to execute
   * 
   * @var string
   */
  public $schedulingId = null;
  /**
   * should the process tasks run with development version data
   * 
   * @var bool
   */
  public $development = null;
  /**
   * are the process tasks incremental processes (or full)
   * 
   * @var bool
   */
  public $delta = null;
  /**
   * if similar process tasks are already running, the forceStart will make the new ones run, otherwise, the execution will be aborted
   * 
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'SchedulingExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SchedulingExecutionParameters');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a time range
 */
class TimeRange {
  static $_TSPEC;

  /**
   * UNIX timestamp of a lower boundary of the range
   * 
   * @var int
   */
  public $from = null;
  /**
   * UNIX timestamp of a upper boundary of the range
   * 
   * @var int
   */
  public $to = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'from',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'to',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['from'])) {
        $this->from = $vals['from'];
      }
      if (isset($vals['to'])) {
        $this->to = $vals['to'];
      }
    }
  }

  public function getName() {
    return 'TimeRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->from);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->to);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeRange');
    if ($this->from !== null) {
      $xfer += $output->writeFieldBegin('from', TType::I64, 1);
      $xfer += $output->writeI64($this->from);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to !== null) {
      $xfer += $output->writeFieldBegin('to', TType::I64, 2);
      $xfer += $output->writeI64($this->to);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a time range value of the KPI
 */
class TimeRangeValue {
  static $_TSPEC;

  /**
   * used time range
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * KPI value for this particular range
   * 
   * @var double
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TimeRangeValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeRangeValue');
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 1);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


