<?php
namespace com\boxalino\dataintelligence\api\thrift;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * This enumeration defines the possible exception states returned by Boxalino Data Intelligence Thrift API
 */
final class DataIntelligenceServiceExceptionNumber {
  /**
   * general case of exception (no special detailed provided)
   */
  const GENERAL_EXCEPTION = 1;
  /**
   * the provided credentials to retrieve an authentication token are not valid (wrong username, password or both)
   */
  const INVALID_CREDENTIALS = 2;
  /**
   * your user has been blocked (but it doesn't necessarily mean your account has been blocked)
   */
  const BLOCKED_USER = 3;
  /**
   * your account has been blocked, you must contact Boxalino (<a href="mailto:support@boxalino.com">support@boxalino.com</a>) to know the reasons of this blocking.
   */
  const BLOCKED_ACCOUNT = 4;
  /**
   * the provided authentication token is invalid (wrong, or no more valid), you should get a new one by calling the GetAuthentication service.
   */
  const INVALID_AUTHENTICATION_TOKEN = 5;
  /**
   * specific to the service function UpdatePassword: means that the new password is not correct (should be at least 8 characters long and not contain any punctuation)
   */
  const INVALID_NEW_PASSWORD = 6;
  /**
   * the provided configuration object contains a configuration version number which doesn't exists or cannot be accessed
   */
  const INVALID_CONFIGURATION_VERSION = 7;
  /**
   * the provided XML data source is not correct (see documentation of the data source XML format)
   */
  const INVALID_DATASOURCE = 8;
  /**
   * the provided content to be changed (updated, deleted, etc.) is defined with a content id which doesn't exists
   */
  const NON_EXISTING_CONTENT_ID = 9;
  /**
   * the provided content id to be created already exists
   */
  const ALREADY_EXISTING_CONTENT_ID = 10;
  /**
   * the provided content id doesn't not match the requested format (less than 50 alphanumeric characters without any punctuation or accent)
   */
  const INVALID_CONTENT_ID = 11;
  /**
   * the provided content data are not correctly set
   */
  const INVALID_CONTENT = 12;
  /**
   * one of the provided languages has not been defined for this account
   */
  const INVALID_LANGUAGE = 13;
  /**
   * the provided file identifier has been already used
   */
  const DUPLICATED_FILE_ID = 14;
  /**
   * the provided list of columns is empty
   */
  const EMPTY_COLUMNS_LIST = 15;
  /**
   * the provided file identifier was not found
   */
  const NON_EXISTING_FILE = 16;
  /**
   * the provided time range is incorrect (start timestamp is higher than the end one)
   */
  const INVALID_RANGE = 17;
  /**
   * the provided report request contains some invalid parameters settings (missing settings, conflicting settings, etc.)
   */
  const INVALID_REPORT_REQUEST = 18;
  static public $__names = array(
    1 => 'GENERAL_EXCEPTION',
    2 => 'INVALID_CREDENTIALS',
    3 => 'BLOCKED_USER',
    4 => 'BLOCKED_ACCOUNT',
    5 => 'INVALID_AUTHENTICATION_TOKEN',
    6 => 'INVALID_NEW_PASSWORD',
    7 => 'INVALID_CONFIGURATION_VERSION',
    8 => 'INVALID_DATASOURCE',
    9 => 'NON_EXISTING_CONTENT_ID',
    10 => 'ALREADY_EXISTING_CONTENT_ID',
    11 => 'INVALID_CONTENT_ID',
    12 => 'INVALID_CONTENT',
    13 => 'INVALID_LANGUAGE',
    14 => 'DUPLICATED_FILE_ID',
    15 => 'EMPTY_COLUMNS_LIST',
    16 => 'NON_EXISTING_FILE',
    17 => 'INVALID_RANGE',
    18 => 'INVALID_REPORT_REQUEST',
  );
}

/**
 * This enumeration defines the version type. All contents are versioned, normally, you want to change the current development version and then, when finished, publish it (so it becomes the new production version and a new development version is created), but it is also possible to access the production version directly
 */
final class ConfigurationVersionType {
  /**
   * this is the normal case, as you want to retrieve the current dev version of your account configuration and not touch the production one
   */
  const CURRENT_DEVELOPMENT_VERSION = 1;
  /**
   * this should only be used in rare cases where you want to recuperate information from the production configuration, but be careful in changing this version as it will immediately affect your production processes!
   */
  const CURRENT_PRODUCTION_VERSION = 2;
  static public $__names = array(
    1 => 'CURRENT_DEVELOPMENT_VERSION',
    2 => 'CURRENT_PRODUCTION_VERSION',
  );
}

final class Language {
  const GERMAN = 1;
  const FRENCH = 2;
  const ENGLISH = 3;
  const ITALIAN = 4;
  const SPANISH = 5;
  const DUTCH = 6;
  const PORTUGUESE = 7;
  const SWEDISH = 8;
  const ARABIC = 9;
  const RUSSIAN = 10;
  const JAPANESE = 11;
  const KOREAN = 12;
  const TURKISH = 13;
  const VIETNAMESE = 14;
  const POLISH = 15;
  const UKRAINIAN = 16;
  const CHINESE_MANDARIN = 17;
  const OTHER = 100;
  static public $__names = array(
    1 => 'GERMAN',
    2 => 'FRENCH',
    3 => 'ENGLISH',
    4 => 'ITALIAN',
    5 => 'SPANISH',
    6 => 'DUTCH',
    7 => 'PORTUGUESE',
    8 => 'SWEDISH',
    9 => 'ARABIC',
    10 => 'RUSSIAN',
    11 => 'JAPANESE',
    12 => 'KOREAN',
    13 => 'TURKISH',
    14 => 'VIETNAMESE',
    15 => 'POLISH',
    16 => 'UKRAINIAN',
    17 => 'CHINESE_MANDARIN',
    100 => 'OTHER',
  );
}

/**
 * This enumeration defines the possible process task execution statuses type (to check the completion of an execution of  process task and its result)
 */
final class ProcessTaskExecutionStatusType {
  /**
   * The process was not started yet
   */
  const WAITING = 1;
  /**
   * The process has started and is currently running
   */
  const STARTED = 2;
  /**
   * The process has finished successfully
   */
  const FINISHED_SUCCESS = 3;
  /**
   * The process has finished, but with some warnings
   */
  const FINISHED_WITH_WARNINGS = 4;
  /**
   * The process has failed
   */
  const FAILED = 5;
  /**
   * The process has been aborted
   */
  const ABORTED = 6;
  static public $__names = array(
    1 => 'WAITING',
    2 => 'STARTED',
    3 => 'FINISHED_SUCCESS',
    4 => 'FINISHED_WITH_WARNINGS',
    5 => 'FAILED',
    6 => 'ABORTED',
  );
}

/**
 * This enumeration defines possible types of columns which can be used in a reference CSV file
 */
final class CSVFileColumnType {
  /**
   * text string encoded using UTF-8 encoding
   */
  const STRING = 1;
  /**
   * signed 64-bit integer
   */
  const INTEGER = 2;
  /**
   * floating point number
   */
  const DOUBLE = 3;
  /**
   * textual representation of the date and time in the format YYYY-MM-DD HH:MM:SS
   */
  const DATETIME = 4;
  /**
   * textual representation of the date in the format YYYY-MM-DD
   */
  const DATE = 5;
  /**
   * textual representation of the time in the format HH:MM:SS
   */
  const TIME = 6;
  /**
   * numerical representation of the date and time as an unsigned 32-bit integer, counting the seconds since the start of the UNIX epoch
   */
  const UNIX_TIMESTAMP = 7;
  static public $__names = array(
    1 => 'STRING',
    2 => 'INTEGER',
    3 => 'DOUBLE',
    4 => 'DATETIME',
    5 => 'DATE',
    6 => 'TIME',
    7 => 'UNIX_TIMESTAMP',
  );
}

/**
 * This enumeration defines possible granularities used in time ranges
 */
final class TimeRangePrecision {
  /**
   * daily precision
   */
  const DAY = 1;
  /**
   * weekly precision
   */
  const WEEK = 2;
  /**
   * monthly precision
   */
  const MONTH = 3;
  /**
   * quarterly precision
   */
  const QUARTER = 4;
  /**
   * yearly precision
   */
  const YEAR = 5;
  /**
   * return all data for provided date range as one
   */
  const ALL = 6;
  static public $__names = array(
    1 => 'DAY',
    2 => 'WEEK',
    3 => 'MONTH',
    4 => 'QUARTER',
    5 => 'YEAR',
    6 => 'ALL',
  );
}

/**
 * This enumeration defines possible report metric types
 */
final class ReportMetricType {
  /**
   * number of unique visitors (or user)
   */
  const VISITORS = 1;
  /**
   * number of visits (or session)
   */
  const VISITS = 2;
  /**
   * number of landing page bounces
   */
  const BOUNCES = 3;
  /**
   * BOUNCES / VISITS
   */
  const BOUNCE_RATE = 4;
  /**
   * number of page views
   */
  const PAGE_VIEWS = 5;
  /**
   * PAGE_VIEWS / VISITS
   */
  const PAGE_VIEWS_PER_VISIT = 6;
  /**
   * average time of visits
   */
  const AVERAGE_TIME_ON_SITE = 7;
  /**
   * number of product views
   */
  const PRODUCT_VIEWS = 8;
  /**
   * PRODUCT_VIEWS / VISITS
   */
  const PRODUCT_VIEWS_PER_VISIT = 9;
  /**
   * number of visits having at least one product view
   */
  const VISITS_WITH_PRODUCT_VIEWS = 10;
  /**
   * VISITS_WITH_PRODUCT_VIEWS / VISITS
   */
  const VISITS_WITH_PRODUCT_VIEWS_RATE = 11;
  /**
   * number of in-site searches
   */
  const SEARCHES = 12;
  /**
   * SEARCHES / VISITS
   */
  const SEARCHES_PER_VISIT = 13;
  /**
   * number of visits having at least one search
   */
  const VISITS_WITH_SEARCHES = 14;
  /**
   * VISITS_WITH_SEARCHES / VISITS
   */
  const VISITS_WITH_SEARCHES_RATE = 15;
  /**
   * number of goals (require identifier to be provided with the choice identifier)
   */
  const GOALS = 16;
  /**
   * GOALS / VISITS (require identifier to be provided with the choice identifier)
   */
  const GOALS_PER_VISIT = 17;
  /**
   * number of visits having at least one goal (require identifier to be provided with the choice identifier)
   */
  const VISITS_WITH_GOALS = 18;
  /**
   * VISITS_WITH_GOALS / VISITS (require identifier to be provided with the choice identifier)
   */
  const VISITS_WITH_GOALS_RATE = 19;
  /**
   * number of transactions
   */
  const TRANSACTIONS = 20;
  /**
   * TRANSACTIONS / VISITS
   */
  const TRANSACTIONS_PER_VISIT = 21;
  /**
   * number of visits having at least one transaction
   */
  const VISITS_WITH_TRANSACTIONS = 22;
  /**
   * VISITS_WITH_TRANSACTIONS / VISITS
   */
  const VISITS_WITH_TRANSACTIONS_RATE = 23;
  /**
   * transaction turnover
   * N.B.: will return zero for all cases which cannot be mapped to any transaction
   */
  const TRANSACTIONS_TURNOVER = 28;
  /**
   * sum of the transaction parameter values (require identifier to be provided with the transaction parameter name)
   * N.B.: will return zero for all cases which cannot be mapped to any transaction
   */
  const TRANSACTIONS_PARAMETER_SUM = 29;
  /**
   * number of add-to-basket events
   */
  const ADD_TO_BASKETS = 24;
  /**
   * ADD_TO_BASKET / VISITS
   */
  const ADD_TO_BASKETS_PER_VISIT = 25;
  /**
   * number of visits having at least one add to basket event
   */
  const VISITS_WITH_ADD_TO_BASKETS = 26;
  /**
   * VISITS_WITH_ADD_TO_BASKETS / VISITS
   */
  const VISITS_WITH_ADD_TO_BASKETS_RATE = 27;
  static public $__names = array(
    1 => 'VISITORS',
    2 => 'VISITS',
    3 => 'BOUNCES',
    4 => 'BOUNCE_RATE',
    5 => 'PAGE_VIEWS',
    6 => 'PAGE_VIEWS_PER_VISIT',
    7 => 'AVERAGE_TIME_ON_SITE',
    8 => 'PRODUCT_VIEWS',
    9 => 'PRODUCT_VIEWS_PER_VISIT',
    10 => 'VISITS_WITH_PRODUCT_VIEWS',
    11 => 'VISITS_WITH_PRODUCT_VIEWS_RATE',
    12 => 'SEARCHES',
    13 => 'SEARCHES_PER_VISIT',
    14 => 'VISITS_WITH_SEARCHES',
    15 => 'VISITS_WITH_SEARCHES_RATE',
    16 => 'GOALS',
    17 => 'GOALS_PER_VISIT',
    18 => 'VISITS_WITH_GOALS',
    19 => 'VISITS_WITH_GOALS_RATE',
    20 => 'TRANSACTIONS',
    21 => 'TRANSACTIONS_PER_VISIT',
    22 => 'VISITS_WITH_TRANSACTIONS',
    23 => 'VISITS_WITH_TRANSACTIONS_RATE',
    28 => 'TRANSACTIONS_TURNOVER',
    29 => 'TRANSACTIONS_PARAMETER_SUM',
    24 => 'ADD_TO_BASKETS',
    25 => 'ADD_TO_BASKETS_PER_VISIT',
    26 => 'VISITS_WITH_ADD_TO_BASKETS',
    27 => 'VISITS_WITH_ADD_TO_BASKETS_RATE',
  );
}

/**
 * This enumeration defines possible report dimension types
 */
final class ReportDimensionType {
  /**
   * is the visitor a new visitor or a returning visitor
   */
  const NEW_VISITOR = 1;
  /**
   * the detected country of the visitor (NULL if none detected)
   */
  const GEO_COUNTRY = 2;
  /**
   * the detected zip code of the visitor (NULL if none detected)
   */
  const GEO_ZIP = 3;
  /**
   * the detected subdivision (Kanton for Switzerland) of the visitor (NULL if none detected)
   */
  const GEO_SUBDIVISION = 4;
  /**
   * the detected city of the visitor (NULL if none detected)
   */
  const GEO_CITY = 4;
  /**
   * the user agent name (most common values: IE,Mobile Safari,Chrome,Firefox,Safari,Android browser,Chrome Mobile,Java,IE Mobile,Opera,Mobile Firefox)
   */
  const BROWSER_NAME = 5;
  /**
   * the user agent version
   */
  const BROWSER_VERSION = 5;
  /**
   * the user agent operating system (most common values: Windows 7,iOS 7,Windows 8.1,iOS 8,Android 4.4 KitKat,OS X 10.9 Mavericks,Windows 8,Windows XP,Windows Vista,Android 4.2 Jelly Bean)
   */
  const OPERATING_SYSTEM = 6;
  /**
   * the user agent device category (most common values: Personal computer,Smartphone,Tablet,Other)
   */
  const DEVICE_CATEGORY = 7;
  /**
   * the AdWords Creative (requires that the AdWords ValueTrack is passed on the url parameter as "&creative={creative}"
   */
  const ADWORDS_CREATIVE = 8;
  /**
   * the AdWords Keyword (requires that the AdWords ValueTrack is passed on the url parameter as "&keyword={keyword}"
   */
  const ADWORDS_KEYWORD = 9;
  /**
   * the different values of a URL parameter (require identifier to be provided with url parameter name)
   */
  const URL_PARAMETER = 50;
  /**
   * the different values of a transaction property (require identifier to be provided with the transaction property name)
   * N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like ChoiceReport, will only work for the visits/visitors with a transaction)
   */
  const TRANSACTION_PROPERTY = 100;
  /**
   * the different values of a customer property (require identifier to be provided with the customer property name)
   * N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like ChoiceReport, will only work for the visits/visitors with a login or other ways to link the customer id to the visitor id)
   */
  const CUSTOMER_PROPERTY = 150;
  /**
   * the different values of a product property (require identifier to be provided with the product property name)
   * N.B.: a connection to the transaction property must be available (e.g.: For visit&visitor-based reporting, like ChoiceReport, will only work for the visits/visitors with a product purchased)
   */
  const PURCHASED_PRODUCT_PROPERTY = 200;
  static public $__names = array(
    1 => 'NEW_VISITOR',
    2 => 'GEO_COUNTRY',
    3 => 'GEO_ZIP',
    4 => 'GEO_SUBDIVISION',
    4 => 'GEO_CITY',
    5 => 'BROWSER_NAME',
    5 => 'BROWSER_VERSION',
    6 => 'OPERATING_SYSTEM',
    7 => 'DEVICE_CATEGORY',
    8 => 'ADWORDS_CREATIVE',
    9 => 'ADWORDS_KEYWORD',
    50 => 'URL_PARAMETER',
    100 => 'TRANSACTION_PROPERTY',
    150 => 'CUSTOMER_PROPERTY',
    200 => 'PURCHASED_PRODUCT_PROPERTY',
  );
}

/**
 * the possible condition operators to be used in a condition target
 */
final class ConditionOperator {
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value match exactly the source string?
   */
  const IS = 1;
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value NOT match exactly the source string?
   */
  const IS_NOT = 2;
  /**
   * when cast as a number, is the number provided in the source number greater (but not equal or smaller) than the ConditionTarget value?
   */
  const IS_GREATER = 3;
  /**
   * when cast as a number, is the number provided in the source number greater or equal (but not smaller) than the ConditionTarget value?
   */
  const IS_GREATER_OR_EQUAL = 4;
  /**
   * when cast as a number, is the number provided in the source number smaller (but not equal or greater) than the ConditionTarget value?
   */
  const IS_SMALLER = 5;
  /**
   * when cast as a number, is the number provided in the source number smaller or equal (but not greater) than the ConditionTarget value?
   */
  const IS_SMALLER_OR_EQUAL = 6;
  /**
   * when cast as a String, is the substring provided in the ConditionTarget value contained in the source string?
   */
  const CONTAINS = 7;
  /**
   * when cast as a String, is the substring provided in the ConditionTarget value NOT contained in the source string?
   */
  const DOES_NOT_CONTAIN = 8;
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value match the first characters of the source string?
   */
  const STARTS_WITH = 9;
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value NOT match the first characters of the source string?
   */
  const DOES_NOT_START_WITH = 10;
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value match the last characters of the source string?
   */
  const ENDS_WITH = 11;
  /**
   * when cast as a String, does the substring provided in the ConditionTarget value NOT match the last characters of the source string?
   */
  const DOES_NOT_END_WITH = 12;
  static public $__names = array(
    1 => 'IS',
    2 => 'IS_NOT',
    3 => 'IS_GREATER',
    4 => 'IS_GREATER_OR_EQUAL',
    5 => 'IS_SMALLER',
    6 => 'IS_SMALLER_OR_EQUAL',
    7 => 'CONTAINS',
    8 => 'DOES_NOT_CONTAIN',
    9 => 'STARTS_WITH',
    10 => 'DOES_NOT_START_WITH',
    11 => 'ENDS_WITH',
    12 => 'DOES_NOT_END_WITH',
  );
}

/**
 * This enumeration defines possible report result value key types.
 * For each report result groups, the system returns a map of ReportResultValues object (i.e.:a map of report metric (kpi) with their values) for each time range.
 * These time ranges can be of different types (absolute defining exactly form a specific moment to another, or relative, starting at 0 for the first key, for cohort analysis).
 */
final class ReportResultTimeRangeType {
  /**
   * an absolute time range (defines the datetime start and end of the reporting values for this key)
   */
  const REAL_TIME = 1;
  /**
   * returns the start and end date time based on timestamp 0 being the beginning of the report (if cohort per day: first value: 0->3600*24, second value: 3600*24->3600*24*2, ...)
   */
  const COHORT = 2;
  static public $__names = array(
    1 => 'REAL_TIME',
    2 => 'COHORT',
  );
}

/**
 * This exception is raised by all the BoxalinoDataIntelligence service function in case of a problem
 */
class DataIntelligenceServiceException extends TException {
  static $_TSPEC;

  /**
   * indicate the exception number based on the enumeration DataIntelligenceServiceExceptionNumber
   * 
   * @var int
   */
  public $exceptionNumber = null;
  /**
   * a textual message to explain the error conditions more in details
   * 
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'exceptionNumber',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['exceptionNumber'])) {
        $this->exceptionNumber = $vals['exceptionNumber'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'DataIntelligenceServiceException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->exceptionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataIntelligenceServiceException');
    if ($this->exceptionNumber !== null) {
      $xfer += $output->writeFieldBegin('exceptionNumber', TType::I32, 1);
      $xfer += $output->writeI32($this->exceptionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the parameters to be send to receive an authentication token (required by all the other services)
 */
class AuthenticationRequest {
  static $_TSPEC;

  /**
   * the name of your account (as provided to you by Boxalino team, if you don't have an account, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $account = null;
  /**
   * usually the same value as account (but can be different for users with smaller rights, if you don't have a username, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $username = null;
  /**
   * as provided by Boxalino, or according to the last password update you have set. If you lost your password, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)
   * 
   * @var string
   */
  public $password = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'account',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['account'])) {
        $this->account = $vals['account'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->account);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthenticationRequest');
    if ($this->account !== null) {
      $xfer += $output->writeFieldBegin('account', TType::STRING, 1);
      $xfer += $output->writeString($this->account);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the authentication object (to pass as authentication proof to all function and services)
 */
class Authentication {
  static $_TSPEC;

  /**
   * the return authentication token is a string valid for one hour
   * 
   * @var string
   */
  public $authenticationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authenticationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['authenticationToken'])) {
        $this->authenticationToken = $vals['authenticationToken'];
      }
    }
  }

  public function getName() {
    return 'Authentication';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->authenticationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Authentication');
    if ($this->authenticationToken !== null) {
      $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
      $xfer += $output->writeString($this->authenticationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration version of your account. It must be provided to all functions accessing / updating or removing information from your account configuration
 */
class ConfigurationVersion {
  static $_TSPEC;

  /**
   * an internal number identifying the configuration version
   * 
   * @var int
   */
  public $configurationVersionNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'configurationVersionNumber',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['configurationVersionNumber'])) {
        $this->configurationVersionNumber = $vals['configurationVersionNumber'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationVersion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->configurationVersionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationVersion');
    if ($this->configurationVersionNumber !== null) {
      $xfer += $output->writeFieldBegin('configurationVersionNumber', TType::I16, 1);
      $xfer += $output->writeI16($this->configurationVersionNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration difference (somethin which has changed between two configuration versions)
 */
class ConfigurationDifference {
  static $_TSPEC;

  /**
   * the type of content which has changed (e.g.: 'field')
   * 
   * @var string
   */
  public $contentType = null;
  /**
   * the content id which has changed (e.g: a field id)
   * 
   * @var string
   */
  public $contentId = null;
  /**
   * the content parameter which has changed (e.g.: a field type)
   * 
   * @var string
   */
  public $parameterName = null;
  /**
   * the string encoded value of the content parameter value of the source configuration
   * 
   * @var string
   */
  public $contentSource = null;
  /**
   * the string encoded value of the content parameter value of the destination configuration
   * 
   * @var string
   */
  public $contentDestination = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contentType',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'contentId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameterName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'contentSource',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'contentDestination',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contentType'])) {
        $this->contentType = $vals['contentType'];
      }
      if (isset($vals['contentId'])) {
        $this->contentId = $vals['contentId'];
      }
      if (isset($vals['parameterName'])) {
        $this->parameterName = $vals['parameterName'];
      }
      if (isset($vals['contentSource'])) {
        $this->contentSource = $vals['contentSource'];
      }
      if (isset($vals['contentDestination'])) {
        $this->contentDestination = $vals['contentDestination'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationDifference';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parameterName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentSource);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentDestination);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationDifference');
    if ($this->contentType !== null) {
      $xfer += $output->writeFieldBegin('contentType', TType::STRING, 1);
      $xfer += $output->writeString($this->contentType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentId !== null) {
      $xfer += $output->writeFieldBegin('contentId', TType::STRING, 2);
      $xfer += $output->writeString($this->contentId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameterName !== null) {
      $xfer += $output->writeFieldBegin('parameterName', TType::STRING, 3);
      $xfer += $output->writeString($this->parameterName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentSource !== null) {
      $xfer += $output->writeFieldBegin('contentSource', TType::STRING, 4);
      $xfer += $output->writeString($this->contentSource);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentDestination !== null) {
      $xfer += $output->writeFieldBegin('contentDestination', TType::STRING, 5);
      $xfer += $output->writeString($this->contentDestination);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Field. A field covers any type of data property (customer property, product properties, etc.). Fields are global for all data sources, but can be used only for special data sources and ignored for others. This grants that the properties are always ready to unify values from different sources, but they don't have to.
 */
class Field {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $fieldId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldId'])) {
        $this->fieldId = $vals['fieldId'];
      }
    }
  }

  public function getName() {
    return 'Field';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Field');
    if ($this->fieldId !== null) {
      $xfer += $output->writeFieldBegin('fieldId', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data ProcessTask. A process task covers any kind of process task to be executed by the system.
 */
class ProcessTask {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $processTaskId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
    }
  }

  public function getName() {
    return 'ProcessTask';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTask');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data synchronisation process task. It is used to get the data from external systems and process it.
 */
class DataSyncProcessTask {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $processTaskId = null;
  /**
   * list of data sources which should be used to get data from
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\DataSource[]
   */
  public $inputs = null;
  /**
   * list of data exports which should be used to push the data into
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\DataExport[]
   */
  public $outputs = null;
  /**
   * defines if it is dev version of the task process
   * 
   * @var bool
   */
  public $dev = false;
  /**
   * defines if this particular task process is differential
   * 
   * @var bool
   */
  public $delta = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'inputs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\DataSource',
            ),
          ),
        3 => array(
          'var' => 'outputs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\DataExport',
            ),
          ),
        4 => array(
          'var' => 'dev',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
      if (isset($vals['inputs'])) {
        $this->inputs = $vals['inputs'];
      }
      if (isset($vals['outputs'])) {
        $this->outputs = $vals['outputs'];
      }
      if (isset($vals['dev'])) {
        $this->dev = $vals['dev'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
    }
  }

  public function getName() {
    return 'DataSyncProcessTask';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->inputs = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \com\boxalino\dataintelligence\api\thrift\DataSource();
              $xfer += $elem5->read($input);
              $this->inputs []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->outputs = array();
            $_size6 = 0;
            $_etype9 = 0;
            $xfer += $input->readListBegin($_etype9, $_size6);
            for ($_i10 = 0; $_i10 < $_size6; ++$_i10)
            {
              $elem11 = null;
              $elem11 = new \com\boxalino\dataintelligence\api\thrift\DataExport();
              $xfer += $elem11->read($input);
              $this->outputs []= $elem11;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->dev);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataSyncProcessTask');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inputs !== null) {
      if (!is_array($this->inputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('inputs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->inputs));
        {
          foreach ($this->inputs as $iter12)
          {
            $xfer += $iter12->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->outputs !== null) {
      if (!is_array($this->outputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('outputs', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->outputs));
        {
          foreach ($this->outputs as $iter13)
          {
            $xfer += $iter13->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dev !== null) {
      $xfer += $output->writeFieldBegin('dev', TType::BOOL, 4);
      $xfer += $output->writeBool($this->dev);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 5);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task Scheduling. A scheduling is a collection of process tasks to be executed one after the other by the system.
 */
class Scheduling {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $schedulingId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
    }
  }

  public function getName() {
    return 'Scheduling';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Scheduling');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task RecommendationBlock. A RecommendationBlock is a visual block of recommendation for one page of your web-site (product detail page, basket page, etc.) you can have several recommendation blocks on the same page.
 */
class RecommendationBlock {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $recommendationBlockId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'recommendationBlockId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['recommendationBlockId'])) {
        $this->recommendationBlockId = $vals['recommendationBlockId'];
      }
    }
  }

  public function getName() {
    return 'RecommendationBlock';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->recommendationBlockId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RecommendationBlock');
    if ($this->recommendationBlockId !== null) {
      $xfer += $output->writeFieldBegin('recommendationBlockId', TType::STRING, 1);
      $xfer += $output->writeString($this->recommendationBlockId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data source. Data source is used to get the data from external systems into DI.
 */
class DataSource {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataSourceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataSourceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataSourceId'])) {
        $this->dataSourceId = $vals['dataSourceId'];
      }
    }
  }

  public function getName() {
    return 'DataSource';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataSource');
    if ($this->dataSourceId !== null) {
      $xfer += $output->writeFieldBegin('dataSourceId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data source type used to get the data from reference csv files defined with the API
 */
class ReferenceCSVDataSource {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataSourceId = null;
  /**
   * identifier of the data source which will be extended by this data source
   * 
   * @var string
   */
  public $extendedDataSourceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataSourceId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'extendedDataSourceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataSourceId'])) {
        $this->dataSourceId = $vals['dataSourceId'];
      }
      if (isset($vals['extendedDataSourceId'])) {
        $this->extendedDataSourceId = $vals['extendedDataSourceId'];
      }
    }
  }

  public function getName() {
    return 'ReferenceCSVDataSource';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->extendedDataSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReferenceCSVDataSource');
    if ($this->dataSourceId !== null) {
      $xfer += $output->writeFieldBegin('dataSourceId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->extendedDataSourceId !== null) {
      $xfer += $output->writeFieldBegin('extendedDataSourceId', TType::STRING, 2);
      $xfer += $output->writeString($this->extendedDataSourceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data export type used to push processed data into
 */
class DataExport {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $dataExportId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dataExportId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dataExportId'])) {
        $this->dataExportId = $vals['dataExportId'];
      }
    }
  }

  public function getName() {
    return 'DataExport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataExportId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataExport');
    if ($this->dataExportId !== null) {
      $xfer += $output->writeFieldBegin('dataExportId', TType::STRING, 1);
      $xfer += $output->writeString($this->dataExportId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data EmailCampaign. A campaign is a parameter holder for a campaign execution. It should not change at each sending, but the parameters (especially cmpid) can and should be changed before any new campaign sending (if new campid applies). For the case of trigger campaigns, the cmpid (and other parameters) usually don't change, but for the case of newsletter campaigns, very often each sending has a different id. In this case, the cmpid must be updated (and the dev configuration should be published) every time.
 */
class EmailCampaign {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $emailCampaignId = null;
  /**
   * the running campaign id which is often specific to the running of a specific newsletter e-mail (should be changed every time before sending a blast e-mail with the new value (don't forget to publish the dev configuration)
   * 
   * @var string
   */
  public $cmpid = null;
  /**
   * the dateTime at which the campaign will be sent (cannot be in the past when the campaign is ran, an exception will be then raised). Must have the format YYYY-MM-DD HH:MM:SS
   * 
   * @var string
   */
  public $dateTime = null;
  /**
   * a localized value of the base url to use for e-mail links
   * 
   * @var array
   */
  public $baseUrl = null;
  /**
   * a localized value of the subject line of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'subject')
   * 
   * @var array
   */
  public $subject = null;
  /**
   * a localized value of the first sentence of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'firstSentence')
   * 
   * @var array
   */
  public $firstSentence = null;
  /**
   * a localized value of the legal notices to be included in the e-mail (default, can be extended by a specific choice variant localized parameters with parameter name 'legals')
   * 
   * @var array
   */
  public $legals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'emailCampaignId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'cmpid',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'dateTime',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'baseUrl',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'subject',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'firstSentence',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        7 => array(
          'var' => 'legals',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['emailCampaignId'])) {
        $this->emailCampaignId = $vals['emailCampaignId'];
      }
      if (isset($vals['cmpid'])) {
        $this->cmpid = $vals['cmpid'];
      }
      if (isset($vals['dateTime'])) {
        $this->dateTime = $vals['dateTime'];
      }
      if (isset($vals['baseUrl'])) {
        $this->baseUrl = $vals['baseUrl'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
      if (isset($vals['firstSentence'])) {
        $this->firstSentence = $vals['firstSentence'];
      }
      if (isset($vals['legals'])) {
        $this->legals = $vals['legals'];
      }
    }
  }

  public function getName() {
    return 'EmailCampaign';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->emailCampaignId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cmpid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dateTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->baseUrl = array();
            $_size14 = 0;
            $_ktype15 = 0;
            $_vtype16 = 0;
            $xfer += $input->readMapBegin($_ktype15, $_vtype16, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $key19 = 0;
              $val20 = '';
              $xfer += $input->readI32($key19);
              $xfer += $input->readString($val20);
              $this->baseUrl[$key19] = $val20;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->subject = array();
            $_size21 = 0;
            $_ktype22 = 0;
            $_vtype23 = 0;
            $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $key26 = 0;
              $val27 = '';
              $xfer += $input->readI32($key26);
              $xfer += $input->readString($val27);
              $this->subject[$key26] = $val27;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->firstSentence = array();
            $_size28 = 0;
            $_ktype29 = 0;
            $_vtype30 = 0;
            $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $key33 = 0;
              $val34 = '';
              $xfer += $input->readI32($key33);
              $xfer += $input->readString($val34);
              $this->firstSentence[$key33] = $val34;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->legals = array();
            $_size35 = 0;
            $_ktype36 = 0;
            $_vtype37 = 0;
            $xfer += $input->readMapBegin($_ktype36, $_vtype37, $_size35);
            for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
            {
              $key40 = 0;
              $val41 = '';
              $xfer += $input->readI32($key40);
              $xfer += $input->readString($val41);
              $this->legals[$key40] = $val41;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmailCampaign');
    if ($this->emailCampaignId !== null) {
      $xfer += $output->writeFieldBegin('emailCampaignId', TType::STRING, 1);
      $xfer += $output->writeString($this->emailCampaignId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cmpid !== null) {
      $xfer += $output->writeFieldBegin('cmpid', TType::STRING, 2);
      $xfer += $output->writeString($this->cmpid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateTime !== null) {
      $xfer += $output->writeFieldBegin('dateTime', TType::STRING, 3);
      $xfer += $output->writeString($this->dateTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->baseUrl !== null) {
      if (!is_array($this->baseUrl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('baseUrl', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->baseUrl));
        {
          foreach ($this->baseUrl as $kiter42 => $viter43)
          {
            $xfer += $output->writeI32($kiter42);
            $xfer += $output->writeString($viter43);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      if (!is_array($this->subject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subject', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->subject));
        {
          foreach ($this->subject as $kiter44 => $viter45)
          {
            $xfer += $output->writeI32($kiter44);
            $xfer += $output->writeString($viter45);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->firstSentence !== null) {
      if (!is_array($this->firstSentence)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('firstSentence', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->firstSentence));
        {
          foreach ($this->firstSentence as $kiter46 => $viter47)
          {
            $xfer += $output->writeI32($kiter46);
            $xfer += $output->writeString($viter47);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legals !== null) {
      if (!is_array($this->legals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('legals', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->legals));
        {
          foreach ($this->legals as $kiter48 => $viter49)
          {
            $xfer += $output->writeI32($kiter48);
            $xfer += $output->writeString($viter49);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice.
 */
class Choice {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $choiceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
    }
  }

  public function getName() {
    return 'Choice';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Choice');
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice variant
 */
class ChoiceVariant {
  static $_TSPEC;

  /**
   * a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters
   * 
   * @var string
   */
  public $choiceVariantId = null;
  /**
   * the choice id of the choice which this variant is associated to
   * 
   * @var string
   */
  public $choiceId = null;
  /**
   * a list of tags this variant is connected to
   * 
   * @var string[]
   */
  public $tags = null;
  /**
   * a list of non-localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
   * 
   * @var array
   */
  public $simpleParameters = null;
  /**
   * a list of localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)
   * 
   * @var array
   */
  public $localizedParemeters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceVariantId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'simpleParameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        5 => array(
          'var' => 'localizedParemeters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::MAP,
            'elem' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::STRING,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::STRING,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceVariantId'])) {
        $this->choiceVariantId = $vals['choiceVariantId'];
      }
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['simpleParameters'])) {
        $this->simpleParameters = $vals['simpleParameters'];
      }
      if (isset($vals['localizedParemeters'])) {
        $this->localizedParemeters = $vals['localizedParemeters'];
      }
    }
  }

  public function getName() {
    return 'ChoiceVariant';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceVariantId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size50 = 0;
            $_etype53 = 0;
            $xfer += $input->readListBegin($_etype53, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $elem55 = null;
              $xfer += $input->readString($elem55);
              $this->tags []= $elem55;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->simpleParameters = array();
            $_size56 = 0;
            $_ktype57 = 0;
            $_vtype58 = 0;
            $xfer += $input->readMapBegin($_ktype57, $_vtype58, $_size56);
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $key61 = '';
              $val62 = array();
              $xfer += $input->readString($key61);
              $val62 = array();
              $_size63 = 0;
              $_etype66 = 0;
              $xfer += $input->readListBegin($_etype66, $_size63);
              for ($_i67 = 0; $_i67 < $_size63; ++$_i67)
              {
                $elem68 = null;
                $xfer += $input->readString($elem68);
                $val62 []= $elem68;
              }
              $xfer += $input->readListEnd();
              $this->simpleParameters[$key61] = $val62;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->localizedParemeters = array();
            $_size69 = 0;
            $_ktype70 = 0;
            $_vtype71 = 0;
            $xfer += $input->readMapBegin($_ktype70, $_vtype71, $_size69);
            for ($_i73 = 0; $_i73 < $_size69; ++$_i73)
            {
              $key74 = '';
              $val75 = array();
              $xfer += $input->readString($key74);
              $val75 = array();
              $_size76 = 0;
              $_etype79 = 0;
              $xfer += $input->readListBegin($_etype79, $_size76);
              for ($_i80 = 0; $_i80 < $_size76; ++$_i80)
              {
                $elem81 = null;
                $elem81 = array();
                $_size82 = 0;
                $_ktype83 = 0;
                $_vtype84 = 0;
                $xfer += $input->readMapBegin($_ktype83, $_vtype84, $_size82);
                for ($_i86 = 0; $_i86 < $_size82; ++$_i86)
                {
                  $key87 = 0;
                  $val88 = '';
                  $xfer += $input->readI32($key87);
                  $xfer += $input->readString($val88);
                  $elem81[$key87] = $val88;
                }
                $xfer += $input->readMapEnd();
                $val75 []= $elem81;
              }
              $xfer += $input->readListEnd();
              $this->localizedParemeters[$key74] = $val75;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceVariant');
    if ($this->choiceVariantId !== null) {
      $xfer += $output->writeFieldBegin('choiceVariantId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceVariantId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 2);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $iter89)
          {
            $xfer += $output->writeString($iter89);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->simpleParameters !== null) {
      if (!is_array($this->simpleParameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('simpleParameters', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->simpleParameters));
        {
          foreach ($this->simpleParameters as $kiter90 => $viter91)
          {
            $xfer += $output->writeString($kiter90);
            {
              $output->writeListBegin(TType::STRING, count($viter91));
              {
                foreach ($viter91 as $iter92)
                {
                  $xfer += $output->writeString($iter92);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localizedParemeters !== null) {
      if (!is_array($this->localizedParemeters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('localizedParemeters', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->localizedParemeters));
        {
          foreach ($this->localizedParemeters as $kiter93 => $viter94)
          {
            $xfer += $output->writeString($kiter93);
            {
              $output->writeListBegin(TType::MAP, count($viter94));
              {
                foreach ($viter94 as $iter95)
                {
                  {
                    $output->writeMapBegin(TType::I32, TType::STRING, count($iter95));
                    {
                      foreach ($iter95 as $kiter96 => $viter97)
                      {
                        $xfer += $output->writeI32($kiter96);
                        $xfer += $output->writeString($viter97);
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a process task execution status (the status of execution of a process task) with its type and a textual message
 */
class ProcessTaskExecutionStatus {
  static $_TSPEC;

  /**
   * the status type of this execution of the process task
   * 
   * @var int
   */
  public $statusType = null;
  /**
   * some additonal information about the type (can be empty, used to explain errors and warnings)
   * 
   * @var string
   */
  public $information = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statusType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'information',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statusType'])) {
        $this->statusType = $vals['statusType'];
      }
      if (isset($vals['information'])) {
        $this->information = $vals['information'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionStatus';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->statusType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->information);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionStatus');
    if ($this->statusType !== null) {
      $xfer += $output->writeFieldBegin('statusType', TType::I32, 1);
      $xfer += $output->writeI32($this->statusType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->information !== null) {
      $xfer += $output->writeFieldBegin('information', TType::STRING, 2);
      $xfer += $output->writeString($this->information);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the execution parameters of a process task
 */
class ProcessTaskExecutionParameters {
  static $_TSPEC;

  /**
   * the process task id to execute
   * 
   * @var string
   */
  public $processTaskId = null;
  /**
   * should the process run with development data that should not to be published into the production environment
   * 
   * @var bool
   */
  public $development = null;
  /**
   * is the process a differential process that adds or updates a part of the existing data, otherwise the new data will replace any existing data completely
   * 
   * @var bool
   */
  public $delta = null;
  /**
   * if another similar process is already running, the forceStart flag will make the new one run, otherwise, the execution will be aborted
   * 
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionParameters');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a reference CSV file descriptor with the identifier and schema
 */
class ReferenceCSVFileDescriptor {
  static $_TSPEC;

  /**
   * identifier of the csv file, needs to be unique per account
   * 
   * @var string
   */
  public $fileId = null;
  /**
   * key-value map of the file columns, where key is a name of the column and value is a column's type
   * 
   * @var array
   */
  public $fileColumns = null;
  /**
   * internal hash used for csv file upload - this property is set by the API and cannot be changed
   * 
   * @var string
   */
  public $fileHash = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fileId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'fileColumns',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        3 => array(
          'var' => 'fileHash',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fileId'])) {
        $this->fileId = $vals['fileId'];
      }
      if (isset($vals['fileColumns'])) {
        $this->fileColumns = $vals['fileColumns'];
      }
      if (isset($vals['fileHash'])) {
        $this->fileHash = $vals['fileHash'];
      }
    }
  }

  public function getName() {
    return 'ReferenceCSVFileDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->fileColumns = array();
            $_size98 = 0;
            $_ktype99 = 0;
            $_vtype100 = 0;
            $xfer += $input->readMapBegin($_ktype99, $_vtype100, $_size98);
            for ($_i102 = 0; $_i102 < $_size98; ++$_i102)
            {
              $key103 = '';
              $val104 = 0;
              $xfer += $input->readString($key103);
              $xfer += $input->readI32($val104);
              $this->fileColumns[$key103] = $val104;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fileHash);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReferenceCSVFileDescriptor');
    if ($this->fileId !== null) {
      $xfer += $output->writeFieldBegin('fileId', TType::STRING, 1);
      $xfer += $output->writeString($this->fileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileColumns !== null) {
      if (!is_array($this->fileColumns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileColumns', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->fileColumns));
        {
          foreach ($this->fileColumns as $kiter105 => $viter106)
          {
            $xfer += $output->writeString($kiter105);
            $xfer += $output->writeI32($viter106);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileHash !== null) {
      $xfer += $output->writeFieldBegin('fileHash', TType::STRING, 3);
      $xfer += $output->writeString($this->fileHash);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a schedulings execution parameters. A scheduling is a collection of process tasks to be executed one after the other by the system.
 */
class SchedulingExecutionParameters {
  static $_TSPEC;

  /**
   * the scheduling id to execute
   * 
   * @var string
   */
  public $schedulingId = null;
  /**
   * should the process tasks run with development version data
   * 
   * @var bool
   */
  public $development = null;
  /**
   * are the process tasks incremental processes (or full)
   * 
   * @var bool
   */
  public $delta = null;
  /**
   * if similar process tasks are already running, the forceStart will make the new ones run, otherwise, the execution will be aborted
   * 
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'SchedulingExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SchedulingExecutionParameters');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a time range
 */
class TimeRange {
  static $_TSPEC;

  /**
   * UNIX timestamp of a lower boundary of the range
   * 
   * @var int
   */
  public $from = null;
  /**
   * UNIX timestamp of a upper boundary of the range
   * 
   * @var int
   */
  public $to = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'from',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'to',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['from'])) {
        $this->from = $vals['from'];
      }
      if (isset($vals['to'])) {
        $this->to = $vals['to'];
      }
    }
  }

  public function getName() {
    return 'TimeRange';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->from);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->to);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeRange');
    if ($this->from !== null) {
      $xfer += $output->writeFieldBegin('from', TType::I64, 1);
      $xfer += $output->writeI64($this->from);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to !== null) {
      $xfer += $output->writeFieldBegin('to', TType::I64, 2);
      $xfer += $output->writeI64($this->to);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a time range value of the KPI
 */
class TimeRangeValue {
  static $_TSPEC;

  /**
   * used time range
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * KPI value for this particular range
   * 
   * @var double
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TimeRangeValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimeRangeValue');
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 1);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a report metric (kpi) which can be standard or custom wiht an identifier (e.g.: for goals)
 */
class ReportMetric {
  static $_TSPEC;

  /**
   * the type of metric
   * 
   * @var int
   */
  public $type = null;
  /**
   * optional, for the ReportMetricType requiring it (e.g.: goal) the identifier the metric
   * 
   * @var string
   */
  public $identifier = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'identifier',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['identifier'])) {
        $this->identifier = $vals['identifier'];
      }
    }
  }

  public function getName() {
    return 'ReportMetric';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportMetric');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->identifier !== null) {
      $xfer += $output->writeFieldBegin('identifier', TType::STRING, 2);
      $xfer += $output->writeString($this->identifier);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a report dimension (segmentation) which can be standard or custom with an identifier (e.g.: for url parameters)
 */
class ReportDimension {
  static $_TSPEC;

  /**
   * the type of metric
   * 
   * @var int
   */
  public $type = null;
  /**
   * optional, for the ReportDimensionType requiring it (e.g.: goal) the identifier the metric
   * 
   * @var string
   */
  public $identifier = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'identifier',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['identifier'])) {
        $this->identifier = $vals['identifier'];
      }
    }
  }

  public function getName() {
    return 'ReportDimension';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportDimension');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->identifier !== null) {
      $xfer += $output->writeFieldBegin('identifier', TType::STRING, 2);
      $xfer += $output->writeString($this->identifier);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * this structure defines the operator and values required for a condition to be true
 * (example: condition "is", value : "123"
 */
class ConditionTarget {
  static $_TSPEC;

  /**
   * the condition target operator ("is", "is not", "greater than", ...)
   * 
   * @var int
   */
  public $operator = null;
  /**
   * the condition value (will be cast in the proper format, so "123" == 123)
   * 
   * @var string
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operator',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operator'])) {
        $this->operator = $vals['operator'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'ConditionTarget';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operator);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConditionTarget');
    if ($this->operator !== null) {
      $xfer += $output->writeFieldBegin('operator', TType::I32, 1);
      $xfer += $output->writeI32($this->operator);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * this structure defines a dimension condition, corresponding to a list of ConditionTargets for a given dimension
 */
class DimensionCondition {
  static $_TSPEC;

  /**
   * the report dimension
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimension
   */
  public $dimension = null;
  /**
   * the list of condition targets to be matched
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ConditionTarget[]
   */
  public $conditionTargets = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dimension',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimension',
          ),
        2 => array(
          'var' => 'conditionTargets',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ConditionTarget',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dimension'])) {
        $this->dimension = $vals['dimension'];
      }
      if (isset($vals['conditionTargets'])) {
        $this->conditionTargets = $vals['conditionTargets'];
      }
    }
  }

  public function getName() {
    return 'DimensionCondition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->dimension = new \com\boxalino\dataintelligence\api\thrift\ReportDimension();
            $xfer += $this->dimension->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->conditionTargets = array();
            $_size107 = 0;
            $_etype110 = 0;
            $xfer += $input->readListBegin($_etype110, $_size107);
            for ($_i111 = 0; $_i111 < $_size107; ++$_i111)
            {
              $elem112 = null;
              $elem112 = new \com\boxalino\dataintelligence\api\thrift\ConditionTarget();
              $xfer += $elem112->read($input);
              $this->conditionTargets []= $elem112;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DimensionCondition');
    if ($this->dimension !== null) {
      if (!is_object($this->dimension)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimension', TType::STRUCT, 1);
      $xfer += $this->dimension->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->conditionTargets !== null) {
      if (!is_array($this->conditionTargets)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditionTargets', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->conditionTargets));
        {
          foreach ($this->conditionTargets as $iter113)
          {
            $xfer += $iter113->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * this structure defines a metric condition, corresponding to a list of ConditionTargets for a given metric
 */
class MetricCondition {
  static $_TSPEC;

  /**
   * the report metric
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric
   */
  public $metric = null;
  /**
   * the list of condition targets to be matched
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ConditionTarget[]
   */
  public $conditionTargets = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metric',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
          ),
        2 => array(
          'var' => 'conditionTargets',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ConditionTarget',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metric'])) {
        $this->metric = $vals['metric'];
      }
      if (isset($vals['conditionTargets'])) {
        $this->conditionTargets = $vals['conditionTargets'];
      }
    }
  }

  public function getName() {
    return 'MetricCondition';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->metric = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
            $xfer += $this->metric->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->conditionTargets = array();
            $_size114 = 0;
            $_etype117 = 0;
            $xfer += $input->readListBegin($_etype117, $_size114);
            for ($_i118 = 0; $_i118 < $_size114; ++$_i118)
            {
              $elem119 = null;
              $elem119 = new \com\boxalino\dataintelligence\api\thrift\ConditionTarget();
              $xfer += $elem119->read($input);
              $this->conditionTargets []= $elem119;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MetricCondition');
    if ($this->metric !== null) {
      if (!is_object($this->metric)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metric', TType::STRUCT, 1);
      $xfer += $this->metric->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->conditionTargets !== null) {
      if (!is_array($this->conditionTargets)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditionTargets', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->conditionTargets));
        {
          foreach ($this->conditionTargets as $iter120)
          {
            $xfer += $iter120->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * this structure defines a report filter (set of and clauses), all of which must be true
 */
class ReportFilter {
  static $_TSPEC;

  /**
   * the dimension filters
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\DimensionCondition[]
   */
  public $dimensionConditions = null;
  /**
   * the metric filters
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\MetricCondition[]
   */
  public $metricConditions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dimensionConditions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\DimensionCondition',
            ),
          ),
        2 => array(
          'var' => 'metricConditions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\MetricCondition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dimensionConditions'])) {
        $this->dimensionConditions = $vals['dimensionConditions'];
      }
      if (isset($vals['metricConditions'])) {
        $this->metricConditions = $vals['metricConditions'];
      }
    }
  }

  public function getName() {
    return 'ReportFilter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->dimensionConditions = array();
            $_size121 = 0;
            $_etype124 = 0;
            $xfer += $input->readListBegin($_etype124, $_size121);
            for ($_i125 = 0; $_i125 < $_size121; ++$_i125)
            {
              $elem126 = null;
              $elem126 = new \com\boxalino\dataintelligence\api\thrift\DimensionCondition();
              $xfer += $elem126->read($input);
              $this->dimensionConditions []= $elem126;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->metricConditions = array();
            $_size127 = 0;
            $_etype130 = 0;
            $xfer += $input->readListBegin($_etype130, $_size127);
            for ($_i131 = 0; $_i131 < $_size127; ++$_i131)
            {
              $elem132 = null;
              $elem132 = new \com\boxalino\dataintelligence\api\thrift\MetricCondition();
              $xfer += $elem132->read($input);
              $this->metricConditions []= $elem132;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportFilter');
    if ($this->dimensionConditions !== null) {
      if (!is_array($this->dimensionConditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimensionConditions', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->dimensionConditions));
        {
          foreach ($this->dimensionConditions as $iter133)
          {
            $xfer += $iter133->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metricConditions !== null) {
      if (!is_array($this->metricConditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metricConditions', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->metricConditions));
        {
          foreach ($this->metricConditions as $iter134)
          {
            $xfer += $iter134->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines an optimization report request
 */
class ChoiceReportRequest {
  static $_TSPEC;

  /**
   * the choice source id (identifying the system being the source of the choices, if you don't have a choice source id already, please contact support@boxalino.com) (must follow the content id format: <= 50 alphanumeric characters without accent or punctuation)
   * 
   * @var string
   */
  public $choiceSourceId = null;
  /**
   * the choice to analyse (e.g.: each landing page is a choice and has several variant potentially, even if only one)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\Choice
   */
  public $choice = null;
  /**
   * the metrics to evaluate report (e.g.: kpis to return)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $metrics = null;
  /**
   * an optional choice variants to use as filters (only return the results for these choicevariants)
   * 
   * @var string[]
   */
  public $choiceVariantIds = null;
  /**
   * an optional flag to indicate that the results should display not only the choice variant, but which recommendation strategies have been used for each choice variant (only applicable if the choice is a recommendation choice)
   * 
   * @var bool
   */
  public $returnRecommendationStrategies = null;
  /**
   * an optional dimension for the report (for segmentation), while groups are different for each type of reporting, the dimension are normally standard (visitor country, device, ...)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimension
   */
  public $dimension = null;
  /**
   * an optional list of metrics to limit the report to only the cases where at least one of the metrics of the list was reached (e.g.: if focusedMetrics are goal-X and goal-Y, then the Metric Transactions will not be returned for all the visits, but only for the visits who did reach goal-X or goal-Y at least once)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $funnelMetrics = null;
  /**
   * the metrics to use for sorting the results
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $sortBys = null;
  /**
   * a required date range for the reporting response (precision is only managed per day)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * a required date range precision if the results should be aggregated per week or month, overall or return for each day
   * 
   * @var int
   */
  public $precision = null;
  /**
   * an optional starting index (e.g.: if the maximum number of results was exceeded and a second page needs to be displayed). First index is 0.
   * 
   * @var int
   */
  public $startIndex = null;
  /**
   * an required number of maximum number of results (one result is one source of date rage data in of values for all kpis)
   * 
   * @var int
   */
  public $maxResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceSourceId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'choice',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\Choice',
          ),
        3 => array(
          'var' => 'metrics',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        4 => array(
          'var' => 'choiceVariantIds',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'returnRecommendationStrategies',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'dimension',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimension',
          ),
        7 => array(
          'var' => 'funnelMetrics',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        8 => array(
          'var' => 'sortBys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        9 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        10 => array(
          'var' => 'precision',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'startIndex',
          'type' => TType::I16,
          ),
        12 => array(
          'var' => 'maxResults',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceSourceId'])) {
        $this->choiceSourceId = $vals['choiceSourceId'];
      }
      if (isset($vals['choice'])) {
        $this->choice = $vals['choice'];
      }
      if (isset($vals['metrics'])) {
        $this->metrics = $vals['metrics'];
      }
      if (isset($vals['choiceVariantIds'])) {
        $this->choiceVariantIds = $vals['choiceVariantIds'];
      }
      if (isset($vals['returnRecommendationStrategies'])) {
        $this->returnRecommendationStrategies = $vals['returnRecommendationStrategies'];
      }
      if (isset($vals['dimension'])) {
        $this->dimension = $vals['dimension'];
      }
      if (isset($vals['funnelMetrics'])) {
        $this->funnelMetrics = $vals['funnelMetrics'];
      }
      if (isset($vals['sortBys'])) {
        $this->sortBys = $vals['sortBys'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['precision'])) {
        $this->precision = $vals['precision'];
      }
      if (isset($vals['startIndex'])) {
        $this->startIndex = $vals['startIndex'];
      }
      if (isset($vals['maxResults'])) {
        $this->maxResults = $vals['maxResults'];
      }
    }
  }

  public function getName() {
    return 'ChoiceReportRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceSourceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->choice = new \com\boxalino\dataintelligence\api\thrift\Choice();
            $xfer += $this->choice->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->metrics = array();
            $_size135 = 0;
            $_etype138 = 0;
            $xfer += $input->readListBegin($_etype138, $_size135);
            for ($_i139 = 0; $_i139 < $_size135; ++$_i139)
            {
              $elem140 = null;
              $elem140 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem140->read($input);
              $this->metrics []= $elem140;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->choiceVariantIds = array();
            $_size141 = 0;
            $_etype144 = 0;
            $xfer += $input->readListBegin($_etype144, $_size141);
            for ($_i145 = 0; $_i145 < $_size141; ++$_i145)
            {
              $elem146 = null;
              $xfer += $input->readString($elem146);
              $this->choiceVariantIds []= $elem146;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->returnRecommendationStrategies);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->dimension = new \com\boxalino\dataintelligence\api\thrift\ReportDimension();
            $xfer += $this->dimension->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->funnelMetrics = array();
            $_size147 = 0;
            $_etype150 = 0;
            $xfer += $input->readListBegin($_etype150, $_size147);
            for ($_i151 = 0; $_i151 < $_size147; ++$_i151)
            {
              $elem152 = null;
              $elem152 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem152->read($input);
              $this->funnelMetrics []= $elem152;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->sortBys = array();
            $_size153 = 0;
            $_etype156 = 0;
            $xfer += $input->readListBegin($_etype156, $_size153);
            for ($_i157 = 0; $_i157 < $_size153; ++$_i157)
            {
              $elem158 = null;
              $elem158 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem158->read($input);
              $this->sortBys []= $elem158;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->precision);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->startIndex);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->maxResults);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceReportRequest');
    if ($this->choiceSourceId !== null) {
      $xfer += $output->writeFieldBegin('choiceSourceId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceSourceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choice !== null) {
      if (!is_object($this->choice)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('choice', TType::STRUCT, 2);
      $xfer += $this->choice->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->metrics !== null) {
      if (!is_array($this->metrics)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metrics', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->metrics));
        {
          foreach ($this->metrics as $iter159)
          {
            $xfer += $iter159->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceVariantIds !== null) {
      if (!is_array($this->choiceVariantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('choiceVariantIds', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->choiceVariantIds));
        {
          foreach ($this->choiceVariantIds as $iter160)
          {
            $xfer += $output->writeString($iter160);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->returnRecommendationStrategies !== null) {
      $xfer += $output->writeFieldBegin('returnRecommendationStrategies', TType::BOOL, 5);
      $xfer += $output->writeBool($this->returnRecommendationStrategies);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dimension !== null) {
      if (!is_object($this->dimension)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimension', TType::STRUCT, 6);
      $xfer += $this->dimension->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->funnelMetrics !== null) {
      if (!is_array($this->funnelMetrics)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('funnelMetrics', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->funnelMetrics));
        {
          foreach ($this->funnelMetrics as $iter161)
          {
            $xfer += $iter161->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortBys !== null) {
      if (!is_array($this->sortBys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortBys', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortBys));
        {
          foreach ($this->sortBys as $iter162)
          {
            $xfer += $iter162->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 9);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->precision !== null) {
      $xfer += $output->writeFieldBegin('precision', TType::I32, 10);
      $xfer += $output->writeI32($this->precision);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startIndex !== null) {
      $xfer += $output->writeFieldBegin('startIndex', TType::I16, 11);
      $xfer += $output->writeI16($this->startIndex);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxResults !== null) {
      $xfer += $output->writeFieldBegin('maxResults', TType::I16, 12);
      $xfer += $output->writeI16($this->maxResults);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a map key (signature) of a choice report result (indication about what this result is about)
 * The ChoiceReport object contains a map with the results. For each key (i.e.: result group) the system returns a list of report metrics (kpis) and value for each date range requested.
 * These keys are, in the case of a ChoiceReport defined by the choice variant and, possibly a specific dimension value of the choice variant.
 * It is possible that there is no value for the dimension, but then there must be a value for the choiceVariant.
 * It is possible that there is no value for the choiceVariant, but then there must be a value for the choiceVariant.
 * It is only possibly that the recommendationStrategy has a value if a choiceVariant value is also provided.
 * It is possible that the 3 variables (choiceVariant, recommendationStrategy and dimensionValue) are all set.
 * Even if allowed by the fact that all of the variables are optional, it is not possible that none of the variables are set.
 */
class ChoiceReportResult {
  static $_TSPEC;

  /**
   * the choice variant of the choice
   * 
   * @var string
   */
  public $choiceVariantId = null;
  /**
   * optional: indicate a specific recommendation strategy which provided the result (only returned for recommendation choices when the flag returnRecommendationStrategies is true)
   * 
   * @var string
   */
  public $recommendationStrategy = null;
  /**
   * an optional dimension value (in case a dimension has been requested for segmentation)
   * 
   * @var string
   */
  public $dimensionValue = null;
  /**
   * the report result values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceVariantId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'recommendationStrategy',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'dimensionValue',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'values',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceVariantId'])) {
        $this->choiceVariantId = $vals['choiceVariantId'];
      }
      if (isset($vals['recommendationStrategy'])) {
        $this->recommendationStrategy = $vals['recommendationStrategy'];
      }
      if (isset($vals['dimensionValue'])) {
        $this->dimensionValue = $vals['dimensionValue'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ChoiceReportResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceVariantId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->recommendationStrategy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dimensionValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->values = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->values->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceReportResult');
    if ($this->choiceVariantId !== null) {
      $xfer += $output->writeFieldBegin('choiceVariantId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceVariantId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->recommendationStrategy !== null) {
      $xfer += $output->writeFieldBegin('recommendationStrategy', TType::STRING, 2);
      $xfer += $output->writeString($this->recommendationStrategy);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dimensionValue !== null) {
      $xfer += $output->writeFieldBegin('dimensionValue', TType::STRING, 3);
      $xfer += $output->writeString($this->dimensionValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_object($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::STRUCT, 4);
      $xfer += $this->values->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a metric value association
 */
class ReportMetricValue {
  static $_TSPEC;

  /**
   * the metric
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric
   */
  public $metric = null;
  /**
   * the metric value
   * 
   * @var double
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metric',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metric'])) {
        $this->metric = $vals['metric'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'ReportMetricValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->metric = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
            $xfer += $this->metric->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportMetricValue');
    if ($this->metric !== null) {
      if (!is_object($this->metric)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metric', TType::STRUCT, 1);
      $xfer += $this->metric->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a dimension value association
 */
class ReportDimensionValue {
  static $_TSPEC;

  /**
   * the dimension
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimension
   */
  public $dimension = null;
  /**
   * the dimension value
   * 
   * @var string
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dimension',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimension',
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dimension'])) {
        $this->dimension = $vals['dimension'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'ReportDimensionValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->dimension = new \com\boxalino\dataintelligence\api\thrift\ReportDimension();
            $xfer += $this->dimension->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportDimensionValue');
    if ($this->dimension !== null) {
      if (!is_object($this->dimension)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimension', TType::STRUCT, 1);
      $xfer += $this->dimension->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines one key value set of report results
 */
class ReportResultKeyValues {
  static $_TSPEC;

  /**
   * the time range key
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * the metric values for this time range key
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetricValue[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetricValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ReportResultKeyValues';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size163 = 0;
            $_etype166 = 0;
            $xfer += $input->readListBegin($_etype166, $_size163);
            for ($_i167 = 0; $_i167 < $_size163; ++$_i167)
            {
              $elem168 = null;
              $elem168 = new \com\boxalino\dataintelligence\api\thrift\ReportMetricValue();
              $xfer += $elem168->read($input);
              $this->values []= $elem168;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportResultKeyValues');
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 1);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter169)
          {
            $xfer += $iter169->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the result values (map of metric and values for each requested time ranges)
 */
class ReportResultValues {
  static $_TSPEC;

  /**
   * the type of report result value time ranges
   * For each report result groups, the system returns a map of ReportResultValues object (i.e.:a map of report metric (kpi) with their values) for each time range.
   * These time ranges can be of different types (absolute defining exactly form a specific moment to another, or relative, starting at 0 for the first key, for cohort analysis).
   * 
   * @var int
   */
  public $type = null;
  /**
   * a map with a key for each time range (each day, each week, each month, ... depending on its meaning provided by the ReportResultTimeRangeType type) providing for each case a map of metric values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultKeyValues[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultKeyValues',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ReportResultValues';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size170 = 0;
            $_etype173 = 0;
            $xfer += $input->readListBegin($_etype173, $_size170);
            for ($_i174 = 0; $_i174 < $_size170; ++$_i174)
            {
              $elem175 = null;
              $elem175 = new \com\boxalino\dataintelligence\api\thrift\ReportResultKeyValues();
              $xfer += $elem175->read($input);
              $this->values []= $elem175;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportResultValues');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter176)
          {
            $xfer += $iter176->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines an optimization report returned
 * This object is specific to ChoiceReportRequest but is similar to all other type of report responses, as the only difference usually is the key object of the result variable (in this case: ChoiceReportResult)
 */
class ChoiceReport {
  static $_TSPEC;

  /**
   * the map of reporting results (one result per ChoiceReportResult: indicating choice variant, dimension value, etc.)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ChoiceReportResult[]
   */
  public $results = null;
  /**
   * the sum result
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $sumResult = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'results',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ChoiceReportResult',
            ),
          ),
        2 => array(
          'var' => 'sumResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['results'])) {
        $this->results = $vals['results'];
      }
      if (isset($vals['sumResult'])) {
        $this->sumResult = $vals['sumResult'];
      }
    }
  }

  public function getName() {
    return 'ChoiceReport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->results = array();
            $_size177 = 0;
            $_etype180 = 0;
            $xfer += $input->readListBegin($_etype180, $_size177);
            for ($_i181 = 0; $_i181 < $_size177; ++$_i181)
            {
              $elem182 = null;
              $elem182 = new \com\boxalino\dataintelligence\api\thrift\ChoiceReportResult();
              $xfer += $elem182->read($input);
              $this->results []= $elem182;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sumResult = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->sumResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceReport');
    if ($this->results !== null) {
      if (!is_array($this->results)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('results', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->results));
        {
          foreach ($this->results as $iter183)
          {
            $xfer += $iter183->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sumResult !== null) {
      if (!is_object($this->sumResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sumResult', TType::STRUCT, 2);
      $xfer += $this->sumResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a transaction report request
 */
class TransactionReportRequest {
  static $_TSPEC;

  /**
   * the metrics to evaluate report (e.g.: kpis to return)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $metrics = null;
  /**
   * an optional list of dimensions for the report (for segmentation), while groups are different for each type of reporting, the dimension are normally standard (visitor country, device, ...)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimension[]
   */
  public $dimensions = null;
  /**
   * the report filter to use
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportFilter
   */
  public $filter = null;
  /**
   * optional: ONLY FOR COHORT ANALYSIS, the cohort customer id field (will consider all transactions of customers having this property indicating the customer id to belong to the same cohort)
   * E.G.: for re-order rate, indicating the customer id field as the cohort customer id field will work, because each time the same customer re-order, then it is the same cohort re-ordering)
   * E.G.: for viral-rate, indicating the customer field which contains the id of the customer who originated the suggestion to buy should be used a cohort customer id field
   * N.B: Please consider that cohort analysis are basing the cohort time grouping on the precision TimeRangePrecision variable of the TransactionReportRequest)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\Field
   */
  public $cohortIdField = null;
  /**
   * the metrics to use for sorting the results
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $sortBys = null;
  /**
   * a required date range for the reporting response (precision is only managed per day)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * a required date range precision if the results should be aggregated per week or month, overall or return for each day
   * 
   * @var int
   */
  public $precision = null;
  /**
   * an optional starting index (e.g.: if the maximum number of results was exceeded and a second page needs to be displayed). First index is 0.
   * 
   * @var int
   */
  public $startIndex = null;
  /**
   * an required number of maximum number of results (one result is one source of date rage data in of values for all kpis)
   * 
   * @var int
   */
  public $maxResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metrics',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        2 => array(
          'var' => 'dimensions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimension',
            ),
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportFilter',
          ),
        4 => array(
          'var' => 'cohortIdField',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\Field',
          ),
        5 => array(
          'var' => 'sortBys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        6 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        7 => array(
          'var' => 'precision',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'startIndex',
          'type' => TType::I16,
          ),
        9 => array(
          'var' => 'maxResults',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metrics'])) {
        $this->metrics = $vals['metrics'];
      }
      if (isset($vals['dimensions'])) {
        $this->dimensions = $vals['dimensions'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['cohortIdField'])) {
        $this->cohortIdField = $vals['cohortIdField'];
      }
      if (isset($vals['sortBys'])) {
        $this->sortBys = $vals['sortBys'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['precision'])) {
        $this->precision = $vals['precision'];
      }
      if (isset($vals['startIndex'])) {
        $this->startIndex = $vals['startIndex'];
      }
      if (isset($vals['maxResults'])) {
        $this->maxResults = $vals['maxResults'];
      }
    }
  }

  public function getName() {
    return 'TransactionReportRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->metrics = array();
            $_size184 = 0;
            $_etype187 = 0;
            $xfer += $input->readListBegin($_etype187, $_size184);
            for ($_i188 = 0; $_i188 < $_size184; ++$_i188)
            {
              $elem189 = null;
              $elem189 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem189->read($input);
              $this->metrics []= $elem189;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->dimensions = array();
            $_size190 = 0;
            $_etype193 = 0;
            $xfer += $input->readListBegin($_etype193, $_size190);
            for ($_i194 = 0; $_i194 < $_size190; ++$_i194)
            {
              $elem195 = null;
              $elem195 = new \com\boxalino\dataintelligence\api\thrift\ReportDimension();
              $xfer += $elem195->read($input);
              $this->dimensions []= $elem195;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->filter = new \com\boxalino\dataintelligence\api\thrift\ReportFilter();
            $xfer += $this->filter->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->cohortIdField = new \com\boxalino\dataintelligence\api\thrift\Field();
            $xfer += $this->cohortIdField->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->sortBys = array();
            $_size196 = 0;
            $_etype199 = 0;
            $xfer += $input->readListBegin($_etype199, $_size196);
            for ($_i200 = 0; $_i200 < $_size196; ++$_i200)
            {
              $elem201 = null;
              $elem201 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem201->read($input);
              $this->sortBys []= $elem201;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->precision);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->startIndex);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->maxResults);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TransactionReportRequest');
    if ($this->metrics !== null) {
      if (!is_array($this->metrics)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metrics', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->metrics));
        {
          foreach ($this->metrics as $iter202)
          {
            $xfer += $iter202->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dimensions !== null) {
      if (!is_array($this->dimensions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimensions', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->dimensions));
        {
          foreach ($this->dimensions as $iter203)
          {
            $xfer += $iter203->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      if (!is_object($this->filter)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 3);
      $xfer += $this->filter->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cohortIdField !== null) {
      if (!is_object($this->cohortIdField)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cohortIdField', TType::STRUCT, 4);
      $xfer += $this->cohortIdField->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortBys !== null) {
      if (!is_array($this->sortBys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortBys', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortBys));
        {
          foreach ($this->sortBys as $iter204)
          {
            $xfer += $iter204->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 6);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->precision !== null) {
      $xfer += $output->writeFieldBegin('precision', TType::I32, 7);
      $xfer += $output->writeI32($this->precision);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startIndex !== null) {
      $xfer += $output->writeFieldBegin('startIndex', TType::I16, 8);
      $xfer += $output->writeI16($this->startIndex);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxResults !== null) {
      $xfer += $output->writeFieldBegin('maxResults', TType::I16, 9);
      $xfer += $output->writeI16($this->maxResults);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a map key (signature) of a transaction report result (indication about what this result is about)
 * The TransactionReport object contains a map with the results. For each key (i.e.: result group) the system returns a list of report metrics (kpis) and value for each date range requested.
 * These keys are, in the case of a TransactionReport defined by a map of dimension values for each requested Dimension
 */
class TransactionReportResult {
  static $_TSPEC;

  /**
   * an required map of dimension values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimensionValue[]
   */
  public $dimensionValues = null;
  /**
   * the report result values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dimensionValues',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimensionValue',
            ),
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dimensionValues'])) {
        $this->dimensionValues = $vals['dimensionValues'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'TransactionReportResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->dimensionValues = array();
            $_size205 = 0;
            $_etype208 = 0;
            $xfer += $input->readListBegin($_etype208, $_size205);
            for ($_i209 = 0; $_i209 < $_size205; ++$_i209)
            {
              $elem210 = null;
              $elem210 = new \com\boxalino\dataintelligence\api\thrift\ReportDimensionValue();
              $xfer += $elem210->read($input);
              $this->dimensionValues []= $elem210;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->values = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->values->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TransactionReportResult');
    if ($this->dimensionValues !== null) {
      if (!is_array($this->dimensionValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimensionValues', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->dimensionValues));
        {
          foreach ($this->dimensionValues as $iter211)
          {
            $xfer += $iter211->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_object($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::STRUCT, 2);
      $xfer += $this->values->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a transaction report returned
 * This object is specific to TransactionReportRequest but is similar to all other type of report responses, as the only difference usually is the key object of the result variable (in this case: TransactionReportResult)
 */
class TransactionReport {
  static $_TSPEC;

  /**
   * the map of reporting results (one result per TransactionReportResult: indicating dimension values)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TransactionReportResult[]
   */
  public $results = null;
  /**
   * the sum result
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $sumResult = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'results',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\TransactionReportResult',
            ),
          ),
        2 => array(
          'var' => 'sumResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['results'])) {
        $this->results = $vals['results'];
      }
      if (isset($vals['sumResult'])) {
        $this->sumResult = $vals['sumResult'];
      }
    }
  }

  public function getName() {
    return 'TransactionReport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->results = array();
            $_size212 = 0;
            $_etype215 = 0;
            $xfer += $input->readListBegin($_etype215, $_size212);
            for ($_i216 = 0; $_i216 < $_size212; ++$_i216)
            {
              $elem217 = null;
              $elem217 = new \com\boxalino\dataintelligence\api\thrift\TransactionReportResult();
              $xfer += $elem217->read($input);
              $this->results []= $elem217;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sumResult = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->sumResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TransactionReport');
    if ($this->results !== null) {
      if (!is_array($this->results)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('results', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->results));
        {
          foreach ($this->results as $iter218)
          {
            $xfer += $iter218->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sumResult !== null) {
      if (!is_object($this->sumResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sumResult', TType::STRUCT, 2);
      $xfer += $this->sumResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a behavior report request
 */
class BehaviorReportRequest {
  static $_TSPEC;

  /**
   * the metrics to evaluate report (e.g.: kpis to return)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $metrics = null;
  /**
   * an optional list of dimensions for the report (for segmentation), while groups are different for each type of reporting, the dimension are normally standard (visitor country, device, ...)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimension[]
   */
  public $dimensions = null;
  /**
   * the report filter to use
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportFilter
   */
  public $filter = null;
  /**
   * the metrics to use for sorting the results
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportMetric[]
   */
  public $sortBys = null;
  /**
   * a required date range for the reporting response (precision is only managed per day)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\TimeRange
   */
  public $range = null;
  /**
   * a required date range precision if the results should be aggregated per week or month, overall or return for each day
   * 
   * @var int
   */
  public $precision = null;
  /**
   * an optional starting index (e.g.: if the maximum number of results was exceeded and a second page needs to be displayed). First index is 0.
   * 
   * @var int
   */
  public $startIndex = null;
  /**
   * an required number of maximum number of results (one result is one source of date rage data in of values for all kpis)
   * 
   * @var int
   */
  public $maxResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'metrics',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        2 => array(
          'var' => 'dimensions',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimension',
            ),
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportFilter',
          ),
        4 => array(
          'var' => 'sortBys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportMetric',
            ),
          ),
        5 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\TimeRange',
          ),
        6 => array(
          'var' => 'precision',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'startIndex',
          'type' => TType::I16,
          ),
        8 => array(
          'var' => 'maxResults',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['metrics'])) {
        $this->metrics = $vals['metrics'];
      }
      if (isset($vals['dimensions'])) {
        $this->dimensions = $vals['dimensions'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['sortBys'])) {
        $this->sortBys = $vals['sortBys'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['precision'])) {
        $this->precision = $vals['precision'];
      }
      if (isset($vals['startIndex'])) {
        $this->startIndex = $vals['startIndex'];
      }
      if (isset($vals['maxResults'])) {
        $this->maxResults = $vals['maxResults'];
      }
    }
  }

  public function getName() {
    return 'BehaviorReportRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->metrics = array();
            $_size219 = 0;
            $_etype222 = 0;
            $xfer += $input->readListBegin($_etype222, $_size219);
            for ($_i223 = 0; $_i223 < $_size219; ++$_i223)
            {
              $elem224 = null;
              $elem224 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem224->read($input);
              $this->metrics []= $elem224;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->dimensions = array();
            $_size225 = 0;
            $_etype228 = 0;
            $xfer += $input->readListBegin($_etype228, $_size225);
            for ($_i229 = 0; $_i229 < $_size225; ++$_i229)
            {
              $elem230 = null;
              $elem230 = new \com\boxalino\dataintelligence\api\thrift\ReportDimension();
              $xfer += $elem230->read($input);
              $this->dimensions []= $elem230;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->filter = new \com\boxalino\dataintelligence\api\thrift\ReportFilter();
            $xfer += $this->filter->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->sortBys = array();
            $_size231 = 0;
            $_etype234 = 0;
            $xfer += $input->readListBegin($_etype234, $_size231);
            for ($_i235 = 0; $_i235 < $_size231; ++$_i235)
            {
              $elem236 = null;
              $elem236 = new \com\boxalino\dataintelligence\api\thrift\ReportMetric();
              $xfer += $elem236->read($input);
              $this->sortBys []= $elem236;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->range = new \com\boxalino\dataintelligence\api\thrift\TimeRange();
            $xfer += $this->range->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->precision);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->startIndex);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->maxResults);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BehaviorReportRequest');
    if ($this->metrics !== null) {
      if (!is_array($this->metrics)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('metrics', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->metrics));
        {
          foreach ($this->metrics as $iter237)
          {
            $xfer += $iter237->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dimensions !== null) {
      if (!is_array($this->dimensions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimensions', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->dimensions));
        {
          foreach ($this->dimensions as $iter238)
          {
            $xfer += $iter238->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      if (!is_object($this->filter)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filter', TType::STRUCT, 3);
      $xfer += $this->filter->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortBys !== null) {
      if (!is_array($this->sortBys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortBys', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortBys));
        {
          foreach ($this->sortBys as $iter239)
          {
            $xfer += $iter239->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->range !== null) {
      if (!is_object($this->range)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('range', TType::STRUCT, 5);
      $xfer += $this->range->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->precision !== null) {
      $xfer += $output->writeFieldBegin('precision', TType::I32, 6);
      $xfer += $output->writeI32($this->precision);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startIndex !== null) {
      $xfer += $output->writeFieldBegin('startIndex', TType::I16, 7);
      $xfer += $output->writeI16($this->startIndex);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxResults !== null) {
      $xfer += $output->writeFieldBegin('maxResults', TType::I16, 8);
      $xfer += $output->writeI16($this->maxResults);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a map key (signature) of a behavior report result (indication about what this result is about)
 * The BehaviorReport object contains a map with the results. For each key (i.e.: result group) the system returns a list of report metrics (kpis) and value for each date range requested.
 * These keys are, in the case of a BehaviorReport defined by a map of dimension values for each requested Dimension
 */
class BehaviorReportResult {
  static $_TSPEC;

  /**
   * an required map of dimension values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportDimensionValue[]
   */
  public $dimensionValues = null;
  /**
   * the report result values
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dimensionValues',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\ReportDimensionValue',
            ),
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dimensionValues'])) {
        $this->dimensionValues = $vals['dimensionValues'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'BehaviorReportResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->dimensionValues = array();
            $_size240 = 0;
            $_etype243 = 0;
            $xfer += $input->readListBegin($_etype243, $_size240);
            for ($_i244 = 0; $_i244 < $_size240; ++$_i244)
            {
              $elem245 = null;
              $elem245 = new \com\boxalino\dataintelligence\api\thrift\ReportDimensionValue();
              $xfer += $elem245->read($input);
              $this->dimensionValues []= $elem245;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->values = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->values->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BehaviorReportResult');
    if ($this->dimensionValues !== null) {
      if (!is_array($this->dimensionValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dimensionValues', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->dimensionValues));
        {
          foreach ($this->dimensionValues as $iter246)
          {
            $xfer += $iter246->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_object($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::STRUCT, 2);
      $xfer += $this->values->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a behavior report returned
 * This object is specific to BehaviorReportRequest but is similar to all other type of report responses, as the only difference usually is the key object of the result variable (in this case: BehaviorReportResult)
 */
class BehaviorReport {
  static $_TSPEC;

  /**
   * the map of reporting results (one result per BehaviorReportResult: indicating dimension values)
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\BehaviorReportResult[]
   */
  public $results = null;
  /**
   * the sum result
   * 
   * @var \com\boxalino\dataintelligence\api\thrift\ReportResultValues
   */
  public $sumResult = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'results',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\dataintelligence\api\thrift\BehaviorReportResult',
            ),
          ),
        2 => array(
          'var' => 'sumResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\dataintelligence\api\thrift\ReportResultValues',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['results'])) {
        $this->results = $vals['results'];
      }
      if (isset($vals['sumResult'])) {
        $this->sumResult = $vals['sumResult'];
      }
    }
  }

  public function getName() {
    return 'BehaviorReport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->results = array();
            $_size247 = 0;
            $_etype250 = 0;
            $xfer += $input->readListBegin($_etype250, $_size247);
            for ($_i251 = 0; $_i251 < $_size247; ++$_i251)
            {
              $elem252 = null;
              $elem252 = new \com\boxalino\dataintelligence\api\thrift\BehaviorReportResult();
              $xfer += $elem252->read($input);
              $this->results []= $elem252;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->sumResult = new \com\boxalino\dataintelligence\api\thrift\ReportResultValues();
            $xfer += $this->sumResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BehaviorReport');
    if ($this->results !== null) {
      if (!is_array($this->results)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('results', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->results));
        {
          foreach ($this->results as $iter253)
          {
            $xfer += $iter253->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sumResult !== null) {
      if (!is_object($this->sumResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sumResult', TType::STRUCT, 2);
      $xfer += $this->sumResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


