<?php
namespace com\boxalino\dataintelligence\api\thrift;

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * This enumeration defines the possible exception states returned by Boxalino Data Intelligence Thrift API
 * 
 * <dl>
 * <dt>GENERAL_EXCEPTION</dt>
 * <dd>general case of exception (no special detailed provided)</dd>
 * 
 * <dt>INVALID_CREDENTIALS</dt>
 * <dd>the provided credentials to retrieve an authentication token are not valid (wrong username, password or both)</dd>
 * 
 * <dt>BLOCKED_USER</dt>
 * <dd>your user has been blocked (but it doesn't necessarily mean your account has been blocked)</dd>
 * 
 * <dt>BLOCKED_ACCOUNT</dt>
 * <dd>your account has been blocked, you must contact Boxalino (<a href="mailto:support@boxalino.com">support@boxalino.com</a>) to know the reasons of this blocking.</dd>
 * 
 * <dt>INVALID_AUTHENTICATION_TOKEN</dt>
 * <dd>the provided authentication token is invalid (wrong, or no more valid), you should get a new one by calling the GetAuthentication service.</dd>
 * 
 * <dt>INVALID_NEW_PASSWORD</dt>
 * <dd>specific to the service function UpdatePassword: means that the new password is not correct (should be at least 8 characters long and not contain any punctuation)</dd>
 * 
 * <dt>INVALID_CONFIGURATION_VERSION</dt>
 * <dd>the provided configuration object contains a configuration version number which doesn't exists or cannot be accessed</dd>
 * </dl>
 * 
 * <dt>INVALID_DATASOURCE</dt>
 * <dd>the provided XML data source is not correct (see documentation of the data source XML format)</dd>
 * </dl>
 * 
 * <dt>NON_EXISTING_CONTENT_ID</dt>
 * <dd>the provided content to be changed (updated, deleted, etc.) is defined with a content id which doesn't exists</dd>
 * </dl>
 * 
 * <dt>ALREADY_EXISTING_CONTENT_ID</dt>
 * <dd>the provided content id to be created already exists</dd>
 * </dl>
 * 
 * <dt>INVALID_CONTENT_ID</dt>
 * <dd>the provided content id doesn't not match the requested format (less than 50 alphanumeric characters without any punctuation or accent)</dd>
 * </dl>
 * 
 * <dt>INVALID_CONTENT</dt>
 * <dd>the provided content data are not correctly set</dd>
 * </dl>
 * 
 * <dt>INVALID_LANGUAGE</dt>
 * <dd>one of the provided languages has not been defined for this account</dd>
 * </dl>
 */
final class DataIntelligenceServiceExceptionNumber {
  const GENERAL_EXCEPTION = 1;
  const INVALID_CREDENTIALS = 2;
  const BLOCKED_USER = 3;
  const BLOCKED_ACCOUNT = 4;
  const INVALID_AUTHENTICATION_TOKEN = 5;
  const INVALID_NEW_PASSWORD = 6;
  const INVALID_CONFIGURATION_VERSION = 7;
  const INVALID_DATASOURCE = 8;
  const NON_EXISTING_CONTENT_ID = 9;
  const ALREADY_EXISTING_CONTENT_ID = 10;
  const INVALID_CONTENT_ID = 11;
  const INVALID_CONTENT = 12;
  const INVALID_LANGUAGE = 13;
  static public $__names = array(
    1 => 'GENERAL_EXCEPTION',
    2 => 'INVALID_CREDENTIALS',
    3 => 'BLOCKED_USER',
    4 => 'BLOCKED_ACCOUNT',
    5 => 'INVALID_AUTHENTICATION_TOKEN',
    6 => 'INVALID_NEW_PASSWORD',
    7 => 'INVALID_CONFIGURATION_VERSION',
    8 => 'INVALID_DATASOURCE',
    9 => 'NON_EXISTING_CONTENT_ID',
    10 => 'ALREADY_EXISTING_CONTENT_ID',
    11 => 'INVALID_CONTENT_ID',
    12 => 'INVALID_CONTENT',
    13 => 'INVALID_LANGUAGE',
  );
}

/**
 * This enumeration defines the version type. All contents are versioned, normally, you want to change the current development version and then, when finished, publish it (so it becomes the new production version and a new development version is created), but it is also possible to access the production version directly
 * 
 * <dl>
 * <dt>CURRENT_DEVELOPMENT_VERSION</dt>
 * <dd>this is the normal case, as you want to retrieve the current dev version of your account configuration and not touch the production one</dd>
 * 
 * <dt>CURRENT_PRODUCTION_VERSION</dt>
 * <dd>this should only be used in rare cases where you want to recuperate information from the production configuration, but be careful in changing this version as it will immediately affect your production processes!</dd>
 * </dl>
 */
final class ConfigurationVersionType {
  const CURRENT_DEVELOPMENT_VERSION = 1;
  const CURRENT_PRODUCTION_VERSION = 2;
  static public $__names = array(
    1 => 'CURRENT_DEVELOPMENT_VERSION',
    2 => 'CURRENT_PRODUCTION_VERSION',
  );
}

final class Language {
  const GERMAN = 1;
  const FRENCH = 2;
  const ENGLISH = 3;
  const ITALIAN = 4;
  const SPANISH = 5;
  const DUTCH = 6;
  const PORTUGUESE = 7;
  const SWEDISH = 8;
  const ARABIC = 9;
  const RUSSIAN = 10;
  const JAPANESE = 11;
  const KOREAN = 12;
  const TURKISH = 13;
  const VIETNAMESE = 14;
  const POLISH = 15;
  const UKRAINIAN = 16;
  const CHINESE_MANDARIN = 17;
  const OTHER = 100;
  static public $__names = array(
    1 => 'GERMAN',
    2 => 'FRENCH',
    3 => 'ENGLISH',
    4 => 'ITALIAN',
    5 => 'SPANISH',
    6 => 'DUTCH',
    7 => 'PORTUGUESE',
    8 => 'SWEDISH',
    9 => 'ARABIC',
    10 => 'RUSSIAN',
    11 => 'JAPANESE',
    12 => 'KOREAN',
    13 => 'TURKISH',
    14 => 'VIETNAMESE',
    15 => 'POLISH',
    16 => 'UKRAINIAN',
    17 => 'CHINESE_MANDARIN',
    100 => 'OTHER',
  );
}

/**
 * This enumeration defines the possible process task execution statuses type (to check the completion of an execution of  process task and its result)
 * 
 * <dl>
 * <dt>WAITING</dt>
 * <dd>The process was not started yet</dd>
 * 
 * <dt>STARTED</dt>
 * <dd>The process has started and is currently running</dd>
 * </dl>
 * 
 * <dt>STARTED</dt>
 * <dd>The process has started and is currently running</dd>
 * </dl>
 * 
 * <dt>FINISHED_SUCCESS</dt>
 * <dd>The process has finished successfully</dd>
 * </dl>
 * 
 * <dt>FINISHED_WITH_WARNINGS</dt>
 * <dd>The process has finished, but with some warnings</dd>
 * </dl>
 * 
 * <dt>FAILED</dt>
 * <dd>The process has failed</dd>
 * </dl>
 * 
 * <dt>ABORTED</dt>
 * <dd>The process has been aborted</dd>
 * </dl>
 */
final class ProcessTaskExecutionStatusType {
  const WAITING = 1;
  const STARTED = 2;
  const FINISHED_SUCCESS = 3;
  const FINISHED_WITH_WARNINGS = 4;
  const FAILED = 5;
  const ABORTED = 6;
  static public $__names = array(
    1 => 'WAITING',
    2 => 'STARTED',
    3 => 'FINISHED_SUCCESS',
    4 => 'FINISHED_WITH_WARNINGS',
    5 => 'FAILED',
    6 => 'ABORTED',
  );
}

/**
 * This exception is raised by all the BoxalinoDataIntelligence service function in case of a problem
 * 
 * <dl>
 * <dt>exceptionNumber</dt>
 * <dd>indicate the exception number based on the enumeration DataIntelligenceServiceExceptionNumber</dd>
 * <dt>message</dt>
 * <dd>a textual message to explain the error conditions more in details</dd>
 * </dl>
 */
class DataIntelligenceServiceException extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $exceptionNumber = null;
  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'exceptionNumber',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['exceptionNumber'])) {
        $this->exceptionNumber = $vals['exceptionNumber'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'DataIntelligenceServiceException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->exceptionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DataIntelligenceServiceException');
    if ($this->exceptionNumber !== null) {
      $xfer += $output->writeFieldBegin('exceptionNumber', TType::I32, 1);
      $xfer += $output->writeI32($this->exceptionNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the parameters to be send to receive an authentication token (required by all the other services)
 * 
 * <dl>
 * <dt>account</dt>
 * <dd>	the name of your account (as provided to you by Boxalino team, if you don't have an account, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)</dd>
 * <dt>username</dt>
 * <dd>	usually the same value as account (but can be different for users with smaller rights, if you don't have a username, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)</dd>
 * <dt>password</dt>
 * <dd>	as provided by Boxalino, or according to the last password update you have set. If you lost your password, contact <a href="mailto:support@boxalino.com">support@boxalino.com</a>)</dd>
 * </dl>
 */
class AuthenticationRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $account = null;
  /**
   * @var string
   */
  public $username = null;
  /**
   * @var string
   */
  public $password = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'account',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['account'])) {
        $this->account = $vals['account'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->account);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthenticationRequest');
    if ($this->account !== null) {
      $xfer += $output->writeFieldBegin('account', TType::STRING, 1);
      $xfer += $output->writeString($this->account);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines the authentication object (to pass as authentication proof to all function and services)
 * 
 * <dl>
 * <dt>authenticationToken</dt>
 * <dd>the return authentication token is a string valid for one hour</dd>
 * </dl>
 */
class Authentication {
  static $_TSPEC;

  /**
   * @var string
   */
  public $authenticationToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authenticationToken',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['authenticationToken'])) {
        $this->authenticationToken = $vals['authenticationToken'];
      }
    }
  }

  public function getName() {
    return 'Authentication';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->authenticationToken);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Authentication');
    if ($this->authenticationToken !== null) {
      $xfer += $output->writeFieldBegin('authenticationToken', TType::STRING, 1);
      $xfer += $output->writeString($this->authenticationToken);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration version of your account. It must be provided to all functions accessing / updating or removing information from your account configuration
 * 
 * <dl>
 * <dt>configurationVersionNumber</dt>
 * <dd>an internal number identifying the configuration version</dd>
 * </dl>
 */
class ConfigurationVersion {
  static $_TSPEC;

  /**
   * @var int
   */
  public $configurationVersionNumber = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'configurationVersionNumber',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['configurationVersionNumber'])) {
        $this->configurationVersionNumber = $vals['configurationVersionNumber'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationVersion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->configurationVersionNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationVersion');
    if ($this->configurationVersionNumber !== null) {
      $xfer += $output->writeFieldBegin('configurationVersionNumber', TType::I16, 1);
      $xfer += $output->writeI16($this->configurationVersionNumber);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a configuration difference (somethin which has changed between two configuration versions)
 * 
 * <dl>
 * <dt>contentType</dt>
 * <dd>the type of content which has changed (e.g.: 'field')</dd>
 * <dt>contentId</dt>
 * <dd>the content id which has changed (e.g: a field id)</dd>
 * <dt>parameterName</dt>
 * <dd>the content parameter which has changed (e.g.: a field type)</dd>
 * <dt>contentSource</dt>
 * <dd>the string encoded value of the content parameter value of the source configuration</dd>
 * <dt>contentDestination</dt>
 * <dd>the string encoded value of the content parameter value of the destination configuration</dd>
 * </dl>
 */
class ConfigurationDifference {
  static $_TSPEC;

  /**
   * @var string
   */
  public $contentType = null;
  /**
   * @var string
   */
  public $contentId = null;
  /**
   * @var string
   */
  public $parameterName = null;
  /**
   * @var string
   */
  public $contentSource = null;
  /**
   * @var string
   */
  public $contentDestination = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contentType',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'contentId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameterName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'contentSource',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'contentDestination',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contentType'])) {
        $this->contentType = $vals['contentType'];
      }
      if (isset($vals['contentId'])) {
        $this->contentId = $vals['contentId'];
      }
      if (isset($vals['parameterName'])) {
        $this->parameterName = $vals['parameterName'];
      }
      if (isset($vals['contentSource'])) {
        $this->contentSource = $vals['contentSource'];
      }
      if (isset($vals['contentDestination'])) {
        $this->contentDestination = $vals['contentDestination'];
      }
    }
  }

  public function getName() {
    return 'ConfigurationDifference';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parameterName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentSource);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentDestination);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ConfigurationDifference');
    if ($this->contentType !== null) {
      $xfer += $output->writeFieldBegin('contentType', TType::STRING, 1);
      $xfer += $output->writeString($this->contentType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentId !== null) {
      $xfer += $output->writeFieldBegin('contentId', TType::STRING, 2);
      $xfer += $output->writeString($this->contentId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameterName !== null) {
      $xfer += $output->writeFieldBegin('parameterName', TType::STRING, 3);
      $xfer += $output->writeString($this->parameterName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentSource !== null) {
      $xfer += $output->writeFieldBegin('contentSource', TType::STRING, 4);
      $xfer += $output->writeString($this->contentSource);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contentDestination !== null) {
      $xfer += $output->writeFieldBegin('contentDestination', TType::STRING, 5);
      $xfer += $output->writeString($this->contentDestination);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Field. A field covers any type of data property (customer property, product properties, etc.). Fields are global for all data sources, but can be used only for special data sources and ignored for others. This grants that the properties are always ready to unify values from different sources, but they don't have to.
 * 
 * <dl>
 * <dt>fieldId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * </dl>
 */
class Field {
  static $_TSPEC;

  /**
   * @var string
   */
  public $fieldId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldId'])) {
        $this->fieldId = $vals['fieldId'];
      }
    }
  }

  public function getName() {
    return 'Field';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Field');
    if ($this->fieldId !== null) {
      $xfer += $output->writeFieldBegin('fieldId', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data ProcessTask. A process task covers any kind of process task to be executed by the system.
 * 
 * <dl>
 * <dt>processTaskId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * </dl>
 */
class ProcessTask {
  static $_TSPEC;

  /**
   * @var string
   */
  public $processTaskId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
    }
  }

  public function getName() {
    return 'ProcessTask';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTask');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task Scheduling. A scheduling is a collection of process tasks to be executed one after the other by the system.
 * 
 * <dl>
 * <dt>schedulingId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * </dl>
 */
class Scheduling {
  static $_TSPEC;

  /**
   * @var string
   */
  public $schedulingId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
    }
  }

  public function getName() {
    return 'Scheduling';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Scheduling');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a task RecommendationBlock. A RecommendationBlock is a visual block of recommendation for one page of your web-site (product detail page, basket page, etc.) you can have several recommendation blocks on the same page.
 * 
 * <dl>
 * <dt>recommendationBlockId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * </dl>
 */
class RecommendationBlock {
  static $_TSPEC;

  /**
   * @var string
   */
  public $recommendationBlockId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'recommendationBlockId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['recommendationBlockId'])) {
        $this->recommendationBlockId = $vals['recommendationBlockId'];
      }
    }
  }

  public function getName() {
    return 'RecommendationBlock';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->recommendationBlockId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RecommendationBlock');
    if ($this->recommendationBlockId !== null) {
      $xfer += $output->writeFieldBegin('recommendationBlockId', TType::STRING, 1);
      $xfer += $output->writeString($this->recommendationBlockId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data EmailCampaign. A campaign is a parameter holder for a campaign execution. It should not change at each sending, but the parameters (especially cmpid) can be
 * (should) be changed before any new campaign sending (if new campid applies). For the case of trigger campaigns, the cmpid (and other parameters) usually don't change, but for the case of newsletter campaigns, very often each sending has a different id. In this case, the cmpid must be updated (and the dev configuration should be published) every time.
 * <dl>
 * <dt>campaignId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * <dt>cmpid</dt>
 * <dd>the running campaign id which is often specific to the running of a specific newsletter e-mail (should be changed every time before sending a blast e-mail with the new value (don't forget to publish the dev configuration)</dd>
 * <dt>dateTime</dt>
 * <dd>the dateTime at which the campaign will be sent (cannot be in the past when the campaign is ran, an exception will be then raised). must have the format (Y-m-d H:i:s)</dd>
 * <dt>baseUrl</dt>
 * <dd>a localized value of the base url to use for e-mail links</dd>
 * <dt>subject</dt>
 * <dd>a localized value of the subject line of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'subject')</dd>
 * <dt>firstSentence</dt>
 * <dd>a localized value of the first sentence of the e-mail (default, can be overwritten by a specific choice variant localized parameters with parameter name 'firstSentence')</dd>
 * <dt>legals</dt>
 * <dd>a localized value of the legal notices to be included in the e-mail (default, can be extended by a specific choice variant localized parameters with parameter name 'legals')</dd>
 * </dl>
 */
class EmailCampaign {
  static $_TSPEC;

  /**
   * @var string
   */
  public $emailCampaignId = null;
  /**
   * @var string
   */
  public $cmpid = null;
  /**
   * @var string
   */
  public $dateTime = null;
  /**
   * @var array
   */
  public $baseUrl = null;
  /**
   * @var array
   */
  public $subject = null;
  /**
   * @var array
   */
  public $firstSentence = null;
  /**
   * @var array
   */
  public $legals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'emailCampaignId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'cmpid',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'dateTime',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'baseUrl',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'subject',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'firstSentence',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        7 => array(
          'var' => 'legals',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['emailCampaignId'])) {
        $this->emailCampaignId = $vals['emailCampaignId'];
      }
      if (isset($vals['cmpid'])) {
        $this->cmpid = $vals['cmpid'];
      }
      if (isset($vals['dateTime'])) {
        $this->dateTime = $vals['dateTime'];
      }
      if (isset($vals['baseUrl'])) {
        $this->baseUrl = $vals['baseUrl'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
      if (isset($vals['firstSentence'])) {
        $this->firstSentence = $vals['firstSentence'];
      }
      if (isset($vals['legals'])) {
        $this->legals = $vals['legals'];
      }
    }
  }

  public function getName() {
    return 'EmailCampaign';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->emailCampaignId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cmpid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dateTime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->baseUrl = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = 0;
              $val6 = '';
              $xfer += $input->readI32($key5);
              $xfer += $input->readString($val6);
              $this->baseUrl[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->subject = array();
            $_size7 = 0;
            $_ktype8 = 0;
            $_vtype9 = 0;
            $xfer += $input->readMapBegin($_ktype8, $_vtype9, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $key12 = 0;
              $val13 = '';
              $xfer += $input->readI32($key12);
              $xfer += $input->readString($val13);
              $this->subject[$key12] = $val13;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->firstSentence = array();
            $_size14 = 0;
            $_ktype15 = 0;
            $_vtype16 = 0;
            $xfer += $input->readMapBegin($_ktype15, $_vtype16, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $key19 = 0;
              $val20 = '';
              $xfer += $input->readI32($key19);
              $xfer += $input->readString($val20);
              $this->firstSentence[$key19] = $val20;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->legals = array();
            $_size21 = 0;
            $_ktype22 = 0;
            $_vtype23 = 0;
            $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $key26 = 0;
              $val27 = '';
              $xfer += $input->readI32($key26);
              $xfer += $input->readString($val27);
              $this->legals[$key26] = $val27;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmailCampaign');
    if ($this->emailCampaignId !== null) {
      $xfer += $output->writeFieldBegin('emailCampaignId', TType::STRING, 1);
      $xfer += $output->writeString($this->emailCampaignId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cmpid !== null) {
      $xfer += $output->writeFieldBegin('cmpid', TType::STRING, 2);
      $xfer += $output->writeString($this->cmpid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateTime !== null) {
      $xfer += $output->writeFieldBegin('dateTime', TType::STRING, 3);
      $xfer += $output->writeString($this->dateTime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->baseUrl !== null) {
      if (!is_array($this->baseUrl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('baseUrl', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->baseUrl));
        {
          foreach ($this->baseUrl as $kiter28 => $viter29)
          {
            $xfer += $output->writeI32($kiter28);
            $xfer += $output->writeString($viter29);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      if (!is_array($this->subject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subject', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->subject));
        {
          foreach ($this->subject as $kiter30 => $viter31)
          {
            $xfer += $output->writeI32($kiter30);
            $xfer += $output->writeString($viter31);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->firstSentence !== null) {
      if (!is_array($this->firstSentence)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('firstSentence', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->firstSentence));
        {
          foreach ($this->firstSentence as $kiter32 => $viter33)
          {
            $xfer += $output->writeI32($kiter32);
            $xfer += $output->writeString($viter33);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legals !== null) {
      if (!is_array($this->legals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('legals', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::I32, TType::STRING, count($this->legals));
        {
          foreach ($this->legals as $kiter34 => $viter35)
          {
            $xfer += $output->writeI32($kiter34);
            $xfer += $output->writeString($viter35);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice.
 * <dl>
 * <dt>choiceId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * </dl>
 */
class Choice {
  static $_TSPEC;

  /**
   * @var string
   */
  public $choiceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
    }
  }

  public function getName() {
    return 'Choice';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Choice');
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a data Choice variant
 * <dl>
 * <dt>choiceVariantId</dt>
 * <dd>a unique id which should not contain any punctuation, only non-accentuated alphabetic and numeric characters and should not be longer than 50 characters</dd>
 * <dt>choiceId</dt>
 * <dd>the choice id of the choice which this variant is associated to</dd>
 * <dt>tags</dt>
 * <dd>a list of tags this variant is connected to</dd>
 * <dt>simpleParameters</dt>
 * <dd>a list of non-localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)</dd>
 * <dt>localizedParemeters</dt>
 * <dd>a list of localized parameters this variant is connected to (for example, to overwrite the campaign properties, keys should have the same name as the campaign parameter name)</dd>
 * </dl>
 */
class ChoiceVariant {
  static $_TSPEC;

  /**
   * @var string
   */
  public $choiceVariantId = null;
  /**
   * @var string
   */
  public $choiceId = null;
  /**
   * @var string[]
   */
  public $tags = null;
  /**
   * @var array
   */
  public $simpleParameters = null;
  /**
   * @var array
   */
  public $localizedParemeters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceVariantId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'simpleParameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        5 => array(
          'var' => 'localizedParemeters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::MAP,
            'elem' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::STRING,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::STRING,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceVariantId'])) {
        $this->choiceVariantId = $vals['choiceVariantId'];
      }
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['simpleParameters'])) {
        $this->simpleParameters = $vals['simpleParameters'];
      }
      if (isset($vals['localizedParemeters'])) {
        $this->localizedParemeters = $vals['localizedParemeters'];
      }
    }
  }

  public function getName() {
    return 'ChoiceVariant';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceVariantId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size36 = 0;
            $_etype39 = 0;
            $xfer += $input->readListBegin($_etype39, $_size36);
            for ($_i40 = 0; $_i40 < $_size36; ++$_i40)
            {
              $elem41 = null;
              $xfer += $input->readString($elem41);
              $this->tags []= $elem41;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->simpleParameters = array();
            $_size42 = 0;
            $_ktype43 = 0;
            $_vtype44 = 0;
            $xfer += $input->readMapBegin($_ktype43, $_vtype44, $_size42);
            for ($_i46 = 0; $_i46 < $_size42; ++$_i46)
            {
              $key47 = '';
              $val48 = array();
              $xfer += $input->readString($key47);
              $val48 = array();
              $_size49 = 0;
              $_etype52 = 0;
              $xfer += $input->readListBegin($_etype52, $_size49);
              for ($_i53 = 0; $_i53 < $_size49; ++$_i53)
              {
                $elem54 = null;
                $xfer += $input->readString($elem54);
                $val48 []= $elem54;
              }
              $xfer += $input->readListEnd();
              $this->simpleParameters[$key47] = $val48;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->localizedParemeters = array();
            $_size55 = 0;
            $_ktype56 = 0;
            $_vtype57 = 0;
            $xfer += $input->readMapBegin($_ktype56, $_vtype57, $_size55);
            for ($_i59 = 0; $_i59 < $_size55; ++$_i59)
            {
              $key60 = '';
              $val61 = array();
              $xfer += $input->readString($key60);
              $val61 = array();
              $_size62 = 0;
              $_etype65 = 0;
              $xfer += $input->readListBegin($_etype65, $_size62);
              for ($_i66 = 0; $_i66 < $_size62; ++$_i66)
              {
                $elem67 = null;
                $elem67 = array();
                $_size68 = 0;
                $_ktype69 = 0;
                $_vtype70 = 0;
                $xfer += $input->readMapBegin($_ktype69, $_vtype70, $_size68);
                for ($_i72 = 0; $_i72 < $_size68; ++$_i72)
                {
                  $key73 = 0;
                  $val74 = '';
                  $xfer += $input->readI32($key73);
                  $xfer += $input->readString($val74);
                  $elem67[$key73] = $val74;
                }
                $xfer += $input->readMapEnd();
                $val61 []= $elem67;
              }
              $xfer += $input->readListEnd();
              $this->localizedParemeters[$key60] = $val61;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceVariant');
    if ($this->choiceVariantId !== null) {
      $xfer += $output->writeFieldBegin('choiceVariantId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceVariantId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 2);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->tags));
        {
          foreach ($this->tags as $iter75)
          {
            $xfer += $output->writeString($iter75);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->simpleParameters !== null) {
      if (!is_array($this->simpleParameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('simpleParameters', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->simpleParameters));
        {
          foreach ($this->simpleParameters as $kiter76 => $viter77)
          {
            $xfer += $output->writeString($kiter76);
            {
              $output->writeListBegin(TType::STRING, count($viter77));
              {
                foreach ($viter77 as $iter78)
                {
                  $xfer += $output->writeString($iter78);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localizedParemeters !== null) {
      if (!is_array($this->localizedParemeters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('localizedParemeters', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->localizedParemeters));
        {
          foreach ($this->localizedParemeters as $kiter79 => $viter80)
          {
            $xfer += $output->writeString($kiter79);
            {
              $output->writeListBegin(TType::MAP, count($viter80));
              {
                foreach ($viter80 as $iter81)
                {
                  {
                    $output->writeMapBegin(TType::I32, TType::STRING, count($iter81));
                    {
                      foreach ($iter81 as $kiter82 => $viter83)
                      {
                        $xfer += $output->writeI32($kiter82);
                        $xfer += $output->writeString($viter83);
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a process task execution status (the status of execution of a process task) with its type and a textual message
 * 
 * <dl>
 * <dt>statusType</dt>
 * <dd>the status type of this execution of the process task</dd>
 * <dt>information</dt>
 * <dd>some additonal information about the type (can be empty, used to explain errors and warnings)</dd>
 * </dl>
 */
class ProcessTaskExecutionStatus {
  static $_TSPEC;

  /**
   * @var int
   */
  public $statusType = null;
  /**
   * @var string
   */
  public $information = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statusType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'information',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statusType'])) {
        $this->statusType = $vals['statusType'];
      }
      if (isset($vals['information'])) {
        $this->information = $vals['information'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionStatus';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->statusType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->information);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionStatus');
    if ($this->statusType !== null) {
      $xfer += $output->writeFieldBegin('statusType', TType::I32, 1);
      $xfer += $output->writeI32($this->statusType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->information !== null) {
      $xfer += $output->writeFieldBegin('information', TType::STRING, 2);
      $xfer += $output->writeString($this->information);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a process tasks execution parameters. A process task covers any kind of process task to be executed by the system.
 * 
 * <dl>
 * <dt>processTaskId</dt>
 * <dd>the process task id to execute</dd>
 * <dt>development</dt>
 * <dd>should the process task run with development version data</dd>
 * <dt>delta</dt>
 * <dd>is the process task an incremental process (or full)</dd>
 * <dt>forceStart</dt>
 * <dd>if another similar process is already running, the forceStart will make the new one run, otherwise, the execution will be aborted</dd>
 * </dl>
 */
class ProcessTaskExecutionParameters {
  static $_TSPEC;

  /**
   * @var string
   */
  public $processTaskId = null;
  /**
   * @var bool
   */
  public $development = null;
  /**
   * @var bool
   */
  public $delta = null;
  /**
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'processTaskId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['processTaskId'])) {
        $this->processTaskId = $vals['processTaskId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'ProcessTaskExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processTaskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProcessTaskExecutionParameters');
    if ($this->processTaskId !== null) {
      $xfer += $output->writeFieldBegin('processTaskId', TType::STRING, 1);
      $xfer += $output->writeString($this->processTaskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * This structure defines a schedulings execution parameters. A scheduling is a collection of process tasks to be executed one after the other by the system.
 * 
 * <dl>
 * <dt>schedulingId</dt>
 * <dd>the scheduling id to execute</dd>
 * <dt>development</dt>
 * <dd>should the process tasks run with development version data</dd>
 * <dt>delta</dt>
 * <dd>are the process tasks incremental processes (or full)</dd>
 * <dt>forceStart</dt>
 * <dd>if similar process tasks are already running, the forceStart will make the new ones run, otherwise, the execution will be aborted</dd>
 * </dl>
 */
class SchedulingExecutionParameters {
  static $_TSPEC;

  /**
   * @var string
   */
  public $schedulingId = null;
  /**
   * @var bool
   */
  public $development = null;
  /**
   * @var bool
   */
  public $delta = null;
  /**
   * @var bool
   */
  public $forceStart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schedulingId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'development',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'delta',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'forceStart',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schedulingId'])) {
        $this->schedulingId = $vals['schedulingId'];
      }
      if (isset($vals['development'])) {
        $this->development = $vals['development'];
      }
      if (isset($vals['delta'])) {
        $this->delta = $vals['delta'];
      }
      if (isset($vals['forceStart'])) {
        $this->forceStart = $vals['forceStart'];
      }
    }
  }

  public function getName() {
    return 'SchedulingExecutionParameters';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schedulingId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->development);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->delta);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->forceStart);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SchedulingExecutionParameters');
    if ($this->schedulingId !== null) {
      $xfer += $output->writeFieldBegin('schedulingId', TType::STRING, 1);
      $xfer += $output->writeString($this->schedulingId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->development !== null) {
      $xfer += $output->writeFieldBegin('development', TType::BOOL, 2);
      $xfer += $output->writeBool($this->development);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->delta !== null) {
      $xfer += $output->writeFieldBegin('delta', TType::BOOL, 3);
      $xfer += $output->writeBool($this->delta);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->forceStart !== null) {
      $xfer += $output->writeFieldBegin('forceStart', TType::BOOL, 4);
      $xfer += $output->writeBool($this->forceStart);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


